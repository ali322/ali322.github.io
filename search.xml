<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CNodeRN 又一个 CNode React-Native App</title>
    <url>/2017/06/10/cnodern/</url>
    <content><![CDATA[<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/ali322/CNodeRN">https://github.com/ali322/CNodeRN</a> 欢迎star,欢迎PR</p>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><ol>
<li>克隆至本地<br><code>git clone https://github.com/ali322/CNodeRN</code></li>
<li>安装依赖包<br><code>npm install</code></li>
<li>在模拟器里面运行<br><code>react-native run-ios</code> 或者 <code>react-native run-android</code></li>
</ol>
<span id="more"></span>

<h3 id="依赖包清单"><a href="#依赖包清单" class="headerlink" title="依赖包清单"></a>依赖包清单</h3><ul>
<li><a href="https://github.com/lwansbrough/react-native-camera">react-native-camera</a></li>
<li><a href="https://github.com/jsdf/react-native-htmlview">react-native-htmlview</a></li>
<li><a href="https://github.com/brentvatne/react-native-scrollable-tab-view">react-native-scrollable-tab-view</a></li>
<li><a href="https://github.com/oblador/react-native-vector-icons">react-native-vector-icons</a></li>
<li><a href="https://github.com/maxs15/react-native-spinkit">react-native-spinkit</a></li>
<li><a href="https://github.com/rtfeldman/seamless-immutable">seamless-immutable</a></li>
<li><a href="https://github.com/reactjs/redux">redux</a></li>
<li><a href="https://github.com/reactjs/react-redux">react-redux</a></li>
<li><a href="https://github.com/rt2zz/redux-persist">redux-persist</a></li>
<li><a href="https://github.com/gaearon/redux-thunk">redux-thunk</a></li>
<li><a href="https://github.com/lodash/lodash">lodash</a></li>
<li><a href="https://github.com/moment/moment">moment</a></li>
<li><a href="https://github.com/Microsoft/react-native-code-push">react-native-code-push</a></li>
</ul>
<h3 id="待完成"><a href="#待完成" class="headerlink" title="待完成"></a>待完成</h3><ul>
<li>改进htmlview组件在android上的兼容性</li>
<li>完善缓存功能</li>
</ul>
]]></content>
      <tags>
        <tag>React-Native</tag>
      </tags>
  </entry>
  <entry>
    <title>gitea + drone 搭建持续集成环境</title>
    <url>/2022/12/06/gitea/</url>
    <content><![CDATA[<h2 id="安装-gitea"><a href="#安装-gitea" class="headerlink" title="安装 gitea"></a>安装 gitea</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O gitea https://dl.gitea.io/gitea/1.17.1/gitea-1.17.1-linux-amd64</span><br><span class="line">chmod +x gitea</span><br><span class="line">./gitea web</span><br></pre></td></tr></table></figure>

<p>注意设置 webhook</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[webhook]</span><br><span class="line">ALLOWED_HOST_LIST = 10.1.1.1</span><br></pre></td></tr></table></figure>

<h2 id="启动-drone"><a href="#启动-drone" class="headerlink" title="启动 drone"></a>启动 drone</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  drone-server:</span><br><span class="line">    image: drone/drone:2</span><br><span class="line">    ports:</span><br><span class="line">      - 2021:80</span><br><span class="line">    restart: always</span><br><span class="line">    volumes:</span><br><span class="line">      - drone-data:/data:rw</span><br><span class="line">    environment:</span><br><span class="line">      - DRONE_AGENTS_ENABLED=<span class="literal">true</span></span><br><span class="line">      - DRONE_GITEA_SERVER=http://10.1.1.1:2020</span><br><span class="line">      - DRONE_GITEA_CLIENT_ID=f1b59dd9-549a-4dcb-abde-e41465a74f2a</span><br><span class="line">      - DRONE_GITEA_CLIENT_SECRET=PK4YvR8Sd65YQYVp46VbSX28DHnawySspq0bxYDczbgs</span><br><span class="line">      - DRONE_RPC_SECRET=bigbrother</span><br><span class="line">      - DRONE_SERVER_HOST=10.1.1.1:2021</span><br><span class="line">      - DRONE_SERVER_PROTO=http</span><br><span class="line">      - DRONE_USER_CREATE=username:root,admin:<span class="literal">true</span></span><br><span class="line">      - DRONE_GIT_ALWAYS_AUTH=<span class="literal">true</span></span><br><span class="line">  drone-agent:</span><br><span class="line">    image: drone/drone-runner-docker:1</span><br><span class="line">    restart: always</span><br><span class="line">    depends_on:</span><br><span class="line">      - drone-server</span><br><span class="line">    volumes:</span><br><span class="line">      - /var/run/docker.sock:/var/run/docker.sock</span><br><span class="line">    environment:</span><br><span class="line">      - DRONE_RPC_PROTO=http</span><br><span class="line">      - DRONE_RPC_HOST=drone-server</span><br><span class="line">      - DRONE_RPC_SECRET=bigbrother</span><br><span class="line">      - DRONE_RUNNER_CAPACITY=2</span><br><span class="line">      - DRONE_RUNNER_NAME=drone-docker-runner</span><br><span class="line">    dns: 114.114.114.114</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  drone-data:</span><br></pre></td></tr></table></figure>

<h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><ul>
<li>前端项目</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">pipeline</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">docker</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">wrtc-frontend</span></span><br><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">restore-cache</span>  </span><br><span class="line">  <span class="attr">image:</span> <span class="string">drillster/drone-volume-cache</span>  </span><br><span class="line">  <span class="attr">settings:</span>  </span><br><span class="line">    <span class="attr">restore:</span> <span class="literal">true</span>  </span><br><span class="line">    <span class="attr">mount:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./.npm-cache</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node_modules</span>  </span><br><span class="line">  <span class="attr">volumes:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cache</span>  </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/cache</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">node:14.19.0</span></span><br><span class="line">  <span class="attr">commands:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">config</span> <span class="string">set</span> <span class="string">cache</span> <span class="string">./.npm-cache</span> <span class="string">--global</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">config</span> <span class="string">set</span> <span class="string">registry</span> <span class="string">https://registry.npm.taobao.org</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">--silent</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">when:</span></span><br><span class="line">    <span class="attr">branch:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">drillster/drone-rsync</span></span><br><span class="line">  <span class="attr">settings:</span></span><br><span class="line">    <span class="attr">hosts:</span> [ <span class="string">&quot;test.example.com&quot;</span> ]</span><br><span class="line">    <span class="attr">user:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">key:</span></span><br><span class="line">      <span class="attr">from_secret:</span> <span class="string">rsync_key</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">22</span></span><br><span class="line">    <span class="attr">source:</span> <span class="string">./dist</span></span><br><span class="line">    <span class="attr">target:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">    <span class="attr">prescript:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">dist</span></span><br><span class="line">    <span class="attr">script:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">cd</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ls</span> <span class="string">-l</span></span><br><span class="line">  <span class="attr">when:</span></span><br><span class="line">    <span class="attr">branch:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">rebuild-cache</span>  </span><br><span class="line">  <span class="attr">image:</span> <span class="string">drillster/drone-volume-cache</span>  </span><br><span class="line">  <span class="attr">settings:</span>  </span><br><span class="line">    <span class="attr">rebuild:</span> <span class="literal">true</span>  </span><br><span class="line">    <span class="attr">mount:</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./.npm-cache</span>  </span><br><span class="line">      <span class="bullet">-</span> <span class="string">./node_modules</span>  </span><br><span class="line">  <span class="attr">volumes:</span>  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cache</span>  </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/cache</span></span><br><span class="line"><span class="attr">volumes:</span>  </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">cache</span>  </span><br><span class="line">    <span class="attr">host:</span>  </span><br><span class="line">      <span class="attr">path:</span> <span class="string">/tmp/cache</span></span><br></pre></td></tr></table></figure>

<ul>
<li>后端项目</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">pipeline</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">docker</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">linux</span></span><br><span class="line"><span class="attr">platform:</span></span><br><span class="line">  <span class="attr">os:</span> <span class="string">linux</span></span><br><span class="line">  <span class="attr">arch:</span> <span class="string">amd64</span></span><br><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">golang:1.17</span></span><br><span class="line">  <span class="attr">commands:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">go</span> <span class="string">env</span> <span class="string">-w</span> <span class="string">GOPROXY=https://goproxy.cn,direct</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">go</span> <span class="string">test</span> <span class="string">-v</span> <span class="string">./...</span></span><br><span class="line">  <span class="attr">when:</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">dev</span></span><br><span class="line">    <span class="attr">event:</span> <span class="string">push</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">golang:1.17</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">deps</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/go</span></span><br><span class="line">  <span class="attr">commands:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">go</span> <span class="string">env</span> <span class="string">-w</span> <span class="string">GOPROXY=https://goproxy.cn,direct</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">CGO_ENABLED=0</span> <span class="string">GOOS=linux</span> <span class="string">GOARCH=amd64</span> <span class="string">go</span> <span class="string">build</span> <span class="string">-ldflags</span> <span class="string">&quot;-X=main.version=$&#123;DRONE_TAG&#125;&quot;</span> <span class="string">main.go</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mv</span> <span class="string">main</span> <span class="string">wrtc</span></span><br><span class="line">  <span class="attr">when:</span></span><br><span class="line">    <span class="attr">event:</span> <span class="string">tag</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">release</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">plugins/gitea-release</span></span><br><span class="line">  <span class="attr">settings:</span></span><br><span class="line">    <span class="attr">api_key:</span> </span><br><span class="line">      <span class="attr">from_secret:</span> <span class="string">api_key</span></span><br><span class="line">    <span class="attr">base_url:</span> <span class="string">http://10.1.1.1/git/</span></span><br><span class="line">    <span class="attr">files:</span> <span class="string">wrtc</span></span><br><span class="line">  <span class="attr">when:</span></span><br><span class="line">    <span class="attr">event:</span> <span class="string">tag</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">deps</span></span><br><span class="line">  <span class="attr">temp:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Koa@2+react 快速开发 isomorphic webapp</title>
    <url>/2016/07/15/isomorphic/</url>
    <content><![CDATA[<h3 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h3><p><a href="https://github.com/ali322/isomorphic-boilerplate">https://github.com/ali322/isomorphic-boilerplate</a> 欢迎star,欢迎PR</p>
<span id="more"></span>

<h1 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发 "></a>快速开发 </h1><ul>
<li>运行<code>npm install</code></li>
<li>运行<code>npm run develop-webpack</code> 注入js和css至模板文件</li>
<li>运行<code>npm run develop</code> 启动开发服务</li>
</ul>
<h1 id="部署至生产环境"><a href="#部署至生产环境" class="headerlink" title="部署至生产环境"></a>部署至生产环境</h1><ul>
<li>运行<code>npm install --production</code></li>
<li>运行<code>npm install pm2 -g</code>(更多文档请见<a href="https://github.com/Unitech/PM2">pm2 文档</a>)</li>
<li>运行<code>pm2 start app.js --name &lt;项目名&gt;</code> 部署至生产</li>
</ul>
<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">__test__/</span><br><span class="line">    |-- client/ <span class="comment">#前端单元测试</span></span><br><span class="line">    |-- server/ <span class="comment">#后端单元测试</span></span><br><span class="line">client/</span><br><span class="line">    |-- asset/      <span class="comment">#图片,字体等等资源</span></span><br><span class="line">    |-- bundle/</span><br><span class="line">        |-- common/     <span class="comment">#公共的css和js</span></span><br><span class="line">        |-- component/  <span class="comment">#组件的css</span></span><br><span class="line">        |-- index/      <span class="comment">#index 页面入口js和css</span></span><br><span class="line">        |-- error/      <span class="comment">#错误页面入口js和css</span></span><br><span class="line">        |-- .../        <span class="comment">#更多的页面入口js和css,类似index</span></span><br><span class="line">    |-- vendor/     <span class="comment">#第三方库文件</span></span><br><span class="line">server/</span><br><span class="line">    |-- controller/ <span class="comment">#express 路由目录</span></span><br><span class="line">    |-- lib/        <span class="comment">#后端库(工具库等等)</span></span><br><span class="line">    |-- router.js   <span class="comment">#后端路由定义文件</span></span><br><span class="line">    |-- bootstrap.js <span class="comment">#初始化后端应用,加载中间件和设置应用</span></span><br><span class="line">shared/</span><br><span class="line">    |-- lib/        <span class="comment">#共享库(后端和前端共用)</span></span><br><span class="line">    |-- chunk/</span><br><span class="line">        |-- common/     <span class="comment">#通用组件(例如:错误组件)</span></span><br><span class="line">        |-- index/      <span class="comment">#index页面所有组件</span></span><br><span class="line">        |-- .../        <span class="comment">#更多的页面所有组件.类似index</span></span><br><span class="line">task/</span><br><span class="line">    |-- config/</span><br><span class="line">        |-- module.json <span class="comment">#定义页面配合,以及css和js路径</span></span><br><span class="line">        |-- vendor.json <span class="comment">#定义第三方库</span></span><br><span class="line">    |-- environment.js  <span class="comment">#定义模块的环境变量</span></span><br><span class="line">    |-- hmr-server.js       <span class="comment">#webpack dev server 入口文件</span></span><br><span class="line">    |-- webpack-inject.js <span class="comment">#注入编译好的js和css至模板</span></span><br><span class="line">    |-- webpack.develop.js <span class="comment">#为开发环境编译模块和第三方库</span></span><br><span class="line">    |-- webpack.production.js <span class="comment">#为生产环境编译模块和第三方库</span></span><br><span class="line">    |-- webpack.hot-update.js <span class="comment">#为热替换开发环境编译模块和第三方库</span></span><br><span class="line">view/</span><br><span class="line">    |-- layout.html <span class="comment">#全部布局文件</span></span><br><span class="line">    |-- index.html  <span class="comment">#index页面模板</span></span><br><span class="line">    |-- *.html      <span class="comment">#更多的页面模板</span></span><br><span class="line">app.js      <span class="comment">#应用入口文件</span></span><br><span class="line">gulpfile.js <span class="comment">#任务入口文件</span></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>nva-client 可视化前端开发客户端</title>
    <url>/2021/06/22/nva-client/</url>
    <content><![CDATA[<p><a href="https://github.com/ali322/nva">nva</a> 脚手架的桌面客户端,无任何环境依赖</p>
<span id="more"></span>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>nva-client 是可视化进行前端开发的桌面客户端</p>
<ul>
<li>初始化基于多种基础模板的项目</li>
<li>简单灵活的配置</li>
<li>集成式的模拟终端显示</li>
<li>内置npm包管理功能,支持添加依赖和重装依赖</li>
<li>npm镜像切换支持</li>
<li>中英文语言国际化支持</li>
<li>自动更新</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>从 <a href="https://github.com/ali322/nva-client/releases">github release</a> 下载二进制安装包或者压缩包</p>
<h2 id="Screenshot"><a href="#Screenshot" class="headerlink" title="Screenshot"></a>Screenshot</h2><p><img src="https://raw.githubusercontent.com/ali322/nva-client/master/snapshot/snapshot.png" alt="snapshot"></p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><ul>
<li>初始化一个新项目</li>
</ul>
<ul>
<li>开发项目</li>
</ul>
<p><img src="/images/nva-client/dev.jpg" alt="dev"></p>
<ul>
<li>构建项目</li>
</ul>
<p><img src="/images/nva-client/build.jpg" alt="build"></p>
<ul>
<li>预览项目</li>
</ul>
<p><img src="/images/nva-client/preview.jpg" alt="preview"></p>
<h2 id="配置项目"><a href="#配置项目" class="headerlink" title="配置项目"></a>配置项目</h2><p>更多配置请参考<a href="https://nva.js.org/">nva 配置文档</a></p>
]]></content>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>nva 简洁高效的前端项目脚手架</title>
    <url>/2018/07/13/nva/</url>
    <content><![CDATA[<p>简洁高效的前端项目脚手架, <a href="https://github.com/ali322/nva">项目地址</a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>nva是一个基于webpack,提供灵活配置的前端项目脚手架工具,既能支持纯前端项目(html+css+js)的开发需求,也能支持同构JS/SSR项目(node+react/node+vue)的开发</p>
<ul>
<li>交互性方式初始化基于多种基础模板的项目</li>
<li>使用 js/json 定义满足项目需求的模拟数据</li>
<li>开箱即用的 Babel, Typescript, Sass, Less, Stylus 支持</li>
<li>单元测试和端到端测试的内置支持</li>
</ul>
<span id="more"></span>

<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>安装环境依赖: <a href="https://nodejs.org/en/">Node.js</a> (&gt;=4.x, 6.x preferred), npm 3+ and <a href="https://git-scm.com/">Git</a></p>
<p>第一步: 安装nva命令行工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install nva -g</span><br></pre></td></tr></table></figure>

<p>第二步: 初始化项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nva init my-project</span><br></pre></td></tr></table></figure>

<p>根据命令行提示填写,包含项目模板,框架,是否单页应用,版本号,描述信息,仓库地址,发布协议等等</p>
<p>第三步: 开始开发</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-project</span><br><span class="line">nva vendor</span><br><span class="line">nva dev -p 3000</span><br></pre></td></tr></table></figure>

<p>使用 <code>nva vendor</code> 将项目第三方依赖包预先打包,提升项目开发编译速度,然后使用 <code>nva dev</code> 启动开发服务器,打开浏览器输入 <code>http://localhost:3000</code>即可看到项目的初始化界面</p>
<p>第四步: 测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>根据不同的项目模板执行不同的单元测试</p>
<p>可选: 集成测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run e2e</span><br></pre></td></tr></table></figure>
<p>基于nightwatch的集成测试,测试浏览器为 chrome,可依照项目目录中的 <code>test/e2e</code> 对照修改为 firefox 或 IE</p>
<p>后续: 打包发布</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nva build</span><br></pre></td></tr></table></figure>

<p>完成源码的编译压缩,静态资源合并压缩,路径处理,html注入,构建版本号处理等等</p>
<h2 id="模块化管理"><a href="#模块化管理" class="headerlink" title="模块化管理"></a>模块化管理</h2><ul>
<li><p>增加模块</p>
<p>添加一个空白模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nva mod my-module</span><br></pre></td></tr></table></figure>

<p>以 other-module 为模板添加一个模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nva mod my-module -t other-module</span><br></pre></td></tr></table></figure>

<p>支持批量添加,多个模块名使用英文逗号 <code>,</code> 分隔</p>
</li>
<li><p>删除模块</p>
<p>删除一个已有的模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nva mod existed-module -d</span><br></pre></td></tr></table></figure>

<p>支持批量删除,多个模块名使用英文逗号 <code>,</code> 分隔</p>
</li>
</ul>
<h2 id="项目模板"><a href="#项目模板" class="headerlink" title="项目模板"></a>项目模板</h2><ul>
<li><p><a href="https://github.com/ali322/frontend-boilerplate">纯前端模板</a></p>
<ul>
<li>react + redux 的多页面项目</li>
<li>react + redux + react-router 的单页面项目</li>
<li>vue + vuex 的多页面项目</li>
<li>vue + vuex + vue-router 的单页面项目</li>
</ul>
</li>
<li><p><a href="https://github.com/ali322/isomorphic-boilerplate">同构JS模板</a></p>
<ul>
<li>react + redux + koa@2 的多页面项目</li>
<li>react + redux + react-router + koa@2 的单页面项目</li>
<li>vue + vuex + koa@2 的多页面项目</li>
<li>vue + vuex + vue-router + koa@2 的单页面项目</li>
</ul>
</li>
</ul>
<h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><p>nva脚手架的工具的初衷是提供尽量简洁高效的方式进行前端项目开发,所以大部分时候使用默认配置即可,但是为了满足不同的业务场景,也提供了灵活的配置入口方便自定义,配置文件都位于项目的 .nva 目录下</p>
<p>.nva 目录结构如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">|-- .nva/</span><br><span class="line">    |-- temp/   <span class="comment"># 编译缓存目录</span></span><br><span class="line">    |-- api/   <span class="comment"># 模拟数据接口服务配置</span></span><br><span class="line">        |-- user.json  <span class="comment"># 模拟用户数据接口配置</span></span><br><span class="line">        |-- ...</span><br><span class="line">    |-- nva.json    <span class="comment"># 全局配置</span></span><br><span class="line">    |-- module.json <span class="comment"># 项目模块设置</span></span><br><span class="line">    |-- vendor.json <span class="comment"># 项目第三方包依赖设置</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>nva.json</code> 全局配置</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>:<span class="string">&quot;isomorphic&quot;</span>,    <span class="comment">/* 项目类型: `frontend`,`isomorphic`,`react-native` */</span></span><br><span class="line">    <span class="string">&quot;spa&quot;</span>:<span class="literal">true</span>            <span class="comment">/* 是否单页面项目(SPA)? */</span></span><br><span class="line">    <span class="string">&quot;entryJSExt&quot;</span>:<span class="string">&quot;.jsx&quot;</span>,    <span class="comment">/* 入口 js 文件扩展名 */</span></span><br><span class="line">    <span class="string">&quot;entryCSSExt&quot;</span>:<span class="string">&quot;.styl&quot;</span>,   <span class="comment">/* 入口 css 文件扩展名 */</span></span><br><span class="line">    <span class="string">&quot;distFolder&quot;</span>: <span class="string">&quot;dist&quot;</span>,   <span class="comment">/* 源码编译目标目录名称 */</span></span><br><span class="line">    <span class="string">&quot;bundleFolder&quot;</span>: <span class="string">&quot;bundle&quot;</span>,   <span class="comment">/* 项目模块父目录名称 */</span></span><br><span class="line">    <span class="string">&quot;vendorFolder&quot;</span>: <span class="string">&quot;vendor&quot;</span>,   <span class="comment">/* 第三方依赖包编译目标目录名称 */</span></span><br><span class="line">    <span class="string">&quot;assetFolder&quot;</span>: <span class="string">&quot;asset&quot;</span>,    <span class="comment">/* 静态资源目录名称 */</span></span><br><span class="line">    <span class="string">&quot;spriteFolder&quot;</span>: <span class="string">&quot;sprites&quot;</span>,    <span class="comment">/* 雪碧图原始图目录名称 */</span></span><br><span class="line">    <span class="string">&quot;fontFolder&quot;</span>: <span class="string">&quot;font&quot;</span>,   <span class="comment">/* 字体目录名称 */</span></span><br><span class="line">    <span class="string">&quot;imageFolder&quot;</span>: <span class="string">&quot;image&quot;</span>,    <span class="comment">/* 图片目录名称 */</span></span><br><span class="line">    <span class="string">&quot;sourcePath&quot;</span>: <span class="string">&quot;src&quot;</span>,    <span class="comment">/* 源码目录名称(仅限纯前端项目) */</span></span><br><span class="line">    <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;page&quot;</span>,    <span class="comment">/* html 文件目录名称 */</span></span><br><span class="line">    <span class="string">&quot;serverFolder&quot;</span>: <span class="string">&quot;server&quot;</span>,   <span class="comment">/* 服务端源码目录(仅限同构JS项目) */</span></span><br><span class="line">    <span class="string">&quot;serverEntryJS&quot;</span>: <span class="string">&quot;bootstrap.js&quot;</span>,    <span class="comment">/* 服务端入口文件(仅限同构JS项目) */</span></span><br><span class="line">    <span class="string">&quot;clientPath&quot;</span>: <span class="string">&quot;client&quot;</span>    <span class="comment">/* 客户端源码目录(仅限同构JS项目) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>module.json</code> 项目模块配置</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;index&quot;</span>: &#123;  <span class="comment">/* 模块名称 */</span></span><br><span class="line">        <span class="string">&quot;html&quot;</span>: [<span class="string">&quot;index.html&quot;</span>],     <span class="comment">/* 入口 html 文件 */</span></span><br><span class="line">        <span class="string">&quot;path&quot;</span>: <span class="string">&quot;index&quot;</span>,            <span class="comment">/* 相对目录名称(相对于 bundleFolder ) */</span></span><br><span class="line">        <span class="string">&quot;vendor&quot;</span>: &#123;<span class="string">&quot;js&quot;</span>: <span class="string">&quot;react&quot;</span>,<span class="string">&quot;css&quot;</span>: <span class="string">&quot;common&quot;</span>&#125;   <span class="comment">/* 模块依赖引用名称,引用自 `vendor.json` */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>vendor.json</code> 第三方依赖包配置</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;js&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;react&quot;</span>:[<span class="string">&quot;react&quot;</span>,<span class="string">&quot;react-dom&quot;</span>]     <span class="comment">/* 定义一个JS依赖引用 */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;css&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;common&quot;</span>:[<span class="string">&quot;font-awesome/css/font-awesome.css&quot;</span>]     <span class="comment">/* 定义一个css依赖引用 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>mock</code> 模拟数据接口服务配置</p>
<p>  简单的模拟接口配置</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/mock/user&quot;</span>,    <span class="comment">/* 接口请求 url */</span></span><br><span class="line">    <span class="string">&quot;method&quot;</span>: <span class="string">&quot;get&quot;</span>,        <span class="comment">/* 接口请求方法名称 */</span></span><br><span class="line">    <span class="string">&quot;response&quot;</span>: &#123;           <span class="comment">/* 接口响应 */</span></span><br><span class="line">        <span class="string">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="string">&quot;data&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;id&quot;</span>: <span class="number">6</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Mr.smith&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>  你也可以使用 <a href="http://json-schema.org/">JSON Schema</a> 一个更具语义化和持续化的模拟数据生成器来生成模拟数据</p>
  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;/mock/users&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;get&quot;</span>,   </span><br><span class="line">    <span class="attr">&quot;response&quot;</span>: &#123;        </span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;id&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;$ref&quot;</span>: <span class="string">&quot;#/definitions/positiveInt&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;string&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;faker&quot;</span>: <span class="string">&quot;name.findName&quot;</span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">&quot;required&quot;</span>: [<span class="string">&quot;id&quot;</span>, <span class="string">&quot;name&quot;</span>],</span><br><span class="line">        <span class="attr">&quot;definitions&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;positiveInt&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;minimum&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">&quot;exclusiveMinimum&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,&#123;</span><br><span class="line">     <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;/mock/user&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;method&quot;</span>: <span class="string">&quot;post&quot;</span>,w</span><br><span class="line">    <span class="attr">&quot;response&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;code&quot;</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="attr">&quot;data&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;status&quot;</span>: <span class="string">&quot;ok&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="子包"><a href="#子包" class="headerlink" title="子包"></a>子包</h2></li>
</ul>
<p>packages 目录下的 <code>nva-core</code> <code>nva-task</code> <code>nva-server</code>的三个子包可以独立安装使用</p>
<ul>
<li><p>nva-core: 基础webpack编译配置,满足一般的构建需求</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&#x27;nva-core&#x27;</span></span><br><span class="line">  <span class="keyword">const</span> buildConfig = config(constants)</span><br><span class="line">  webpack(&#123;</span><br><span class="line">    ...buildConfig,</span><br><span class="line">    <span class="attr">entry</span>:<span class="string">&#x27;index.js&#x27;</span>,</span><br><span class="line">    <span class="attr">output</span>:&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).run(<span class="function">(<span class="params">err,stats</span>)=&gt;</span>&#123; ... &#125;)</span><br><span class="line">  <span class="string">``</span></span><br><span class="line">  </span><br><span class="line">- nva-task: nva构建任务集合,可以根据需求自定义组合</span><br><span class="line"></span><br><span class="line">  <span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">  var tasks = require(&#x27;nva-tasks&#x27;)</span></span><br><span class="line"><span class="string">  tasks.frontend.build() //前端项目构建</span></span><br><span class="line"><span class="string">  task.isomorphic.build()  //同构JS项目构建</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>nva-server: 基于connect的前端开发服务,带模拟数据接口功能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;nva-server&#x27;</span></span><br><span class="line"><span class="keyword">let</span> app = App()</span><br><span class="line">app.listen(<span class="number">3000</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;==&gt; server stared at %d&#x27;</span>,<span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>也可以通过命令行方式调用,具体参数说明请参见 <a href="https://github.com/ali322/nva/blob/master/packages/nva-server/README.md">nva-task</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nva-server -p 5000 -P src</span><br></pre></td></tr></table></figure>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2></li>
</ul>
<p>Q: 项目初始化缓慢?<br>A: 因为在项目初始化的使用 npm install 安装项目必须的依赖包,而 npm install 在国内网络环境下你懂的,因此如果长时间没有显示 success,推荐使用 ctrl+d 终止进行,然后进入项目目录执行 cnpm install 或者使用 yarn install</p>
<p>Q: nva安装缓慢?<br>A: 同上,建议使用 <code>cnpm install nva -g</code> 或者 <code>yarn global add nva</code></p>
<p>Q: nva中的包是否可以独立使用?<br>A: 可以,nva的依赖包 nva-core 和 nva-server 都可以独立使用,使用 npm 安装即可</p>
<p>Q: 如何更新nva?<br>A: 使用 <code>npm install nva -g</code> 覆盖安装 </p>
]]></content>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>Reed 基于miniflux的RSS应用</title>
    <url>/2020/08/15/reed/</url>
    <content><![CDATA[<p>Simple RSS Reader based on <a href="https://miniflux.app/">Miniflux</a> API</p>
<span id="more"></span>

<h2 id="Prerequirement"><a href="#Prerequirement" class="headerlink" title="Prerequirement"></a>Prerequirement</h2><ul>
<li>follow <a href="https://miniflux.app/docs/installation.html">Miniflux Documentation</a> to deploy your site</li>
<li>get api key from <code>Settings -&gt; API Keys</code> of your site</li>
</ul>
<h2 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h2><p>go to <a href="https://github.com/ali322/reed/releases">release page</a> download app</p>
<h2 id="ScreenShot"><a href="#ScreenShot" class="headerlink" title="ScreenShot"></a>ScreenShot</h2><ul>
<li>Lignt Mode</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ali322/reed/master/screenshot/1.jpg" alt="1"><br><img src="https://raw.githubusercontent.com/ali322/reed/master/screenshot/2.jpg" alt="2"></p>
<ul>
<li>Dark Mode</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ali322/reed/master/screenshot/3.jpg" alt="3"><br><img src="https://raw.githubusercontent.com/ali322/reed/master/screenshot/4.jpg" alt="4"></p>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul>
<li>support dark mode</li>
<li>i18n enabled</li>
<li>simple and clean theme</li>
</ul>
<h2 id="Develop"><a href="#Develop" class="headerlink" title="Develop"></a>Develop</h2><p>make sure finish <a href="https://flutter.io/get-started/install/">install Flutter</a> successful</p>
<ol>
<li>clone this repo<br><code>git clone https://github.com/ali322/reed</code></li>
<li>install all the packages<br><code>flutter packages get</code></li>
<li>run the app in simulator on your own<br><code>flutter run</code></li>
</ol>
<h2 id="Packages-in-using"><a href="#Packages-in-using" class="headerlink" title="Packages in using"></a>Packages in using</h2><p>Reed build on following packages</p>
<ul>
<li><a href="https://pub.dev/packages/http">http</a></li>
<li><a href="https://pub.dev/packages/bloc">bloc</a></li>
<li><a href="https://pub.dev/packages/flutter_html">flutter_html</a></li>
<li><a href="https://pub.dev/packages/easy_localization">easy_localization</a></li>
<li><a href="https://pub.dev/packages/flutter_secure_storage">flutter_secure_storage</a></li>
<li><a href="https://pub.dev/packages/url_launcher">url_launcher</a></li>
</ul>
<h2 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h2><ul>
<li>finish more scenes</li>
<li>fix some unknow bugs</li>
</ul>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="http://en.wikipedia.org/wiki/MIT_License">MIT License</a></p>
]]></content>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>Cnoder 迁移记</title>
    <url>/2019/02/10/cnoder/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在学会 React-Native 后写了一个 cnodejs社区的客户端 <a href="https://github.com/ali322/CNodeRN">CNodeRN</a>,前阵子了解了下 flutter, 感觉是移动应用开发的未来趋势,便有了迁移至 flutter 技术栈的想法, 然后就有了 <a href="https://github.com/ali322/cnoder">CNoder</a> 这个项目, 也算是对数周 flutter 的一个学习实践吧</p>
<span id="more"></span>

<h2 id="安装和初始化"><a href="#安装和初始化" class="headerlink" title="安装和初始化"></a>安装和初始化</h2><p>跟着官方的<a href="https://flutter.io/setup-macos/">安装说明</a>一步一步往下走,还是挺顺利的,唯一不同的就是增加了镜像设置这一步, 打开 <code>~/.zhsrc</code>, 末尾增加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment">## flutter</span></span><br><span class="line">125 <span class="built_in">export</span> PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">126 <span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br><span class="line">127 <span class="built_in">export</span> PATH=<span class="variable">$HOME</span>/flutter/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>然后执行 <code>flutter doctor</code> 检查环境是否正常,一切顺利的话就可以初始化项目了,我使用的编辑器是 <code>vscode</code>, 通过命令窗口运行命令 <code>Flutter: New Project</code> 即可</p>
<h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><p>源码都位于 <code>lib</code> 目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">|-- config/</span><br><span class="line">    |-- api.dart // http api 调用接口地址配置</span><br><span class="line">|-- common/</span><br><span class="line">    |-- helper.dart // 工具函数</span><br><span class="line">|-- route/</span><br><span class="line">    |-- handler.dart // 路由配置文件</span><br><span class="line">|-- store/</span><br><span class="line">    |-- action/  // redux action 目录</span><br><span class="line">    |-- epic/   // redux_epic 配置目录</span><br><span class="line">    |-- reducer/ // redux reducer 目录</span><br><span class="line">    |-- model/ // 模型目录</span><br><span class="line">    |-- view_model/ // store 映射模型目录</span><br><span class="line">    |-- root_state.dart // 全局 state</span><br><span class="line">    |-- index.dart // store 初始入口</span><br><span class="line">|-- container/  // 连接 store 的容器目录</span><br><span class="line">|-- widget/ // 视图 widget 目录</span><br><span class="line">main.dart // 入口文件</span><br><span class="line">app.dart // 入口widget</span><br></pre></td></tr></table></figure>

<h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><ul>
<li>入口文件: main.dart, 逻辑很简单就不描述了</li>
<li>入口widget: app.dart文件</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化路由插件</span></span><br><span class="line">  <span class="keyword">final</span> Router router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">  App() &#123;</span><br><span class="line">    <span class="comment">// 从持久化存储里加载数据状态,这里用来存储用户的身份令牌信息</span></span><br><span class="line">    persistor.load(store);</span><br><span class="line">    <span class="comment">// 404处理</span></span><br><span class="line">    router.notFoundHandler = notFoundHandler;</span><br><span class="line">    <span class="comment">// 应用路由配置</span></span><br><span class="line">    handlers.forEach((<span class="built_in">String</span> path,Handler handler) &#123;</span><br><span class="line">      router.define(path, handler: handler);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">final</span> app = <span class="keyword">new</span> MaterialApp(</span><br><span class="line">        title: <span class="string">&#x27;CNoder&#x27;</span>,</span><br><span class="line">        <span class="comment">// 禁用右上角的 debug 标志</span></span><br><span class="line">        debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">        theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">          primarySwatch: Colors.lightGreen,</span><br><span class="line">          <span class="comment">// 定义全局图标主题</span></span><br><span class="line">          iconTheme: <span class="keyword">new</span> IconThemeData(</span><br><span class="line">            color: Color(<span class="number">0xFF666666</span>)</span><br><span class="line">          ),</span><br><span class="line">          <span class="comment">// 定义全局文本主题</span></span><br><span class="line">          textTheme: <span class="keyword">new</span> TextTheme(</span><br><span class="line">            body1: <span class="keyword">new</span> TextStyle(color: Color(<span class="number">0xFF333333</span>), fontSize: <span class="number">14.0</span>)</span><br><span class="line">          )</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 将 应用的路由映射至 fluro 的路由表里面去</span></span><br><span class="line">        onGenerateRoute: router.generator</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>  <span class="keyword">new</span> StoreProvider&lt;RootState&gt;(store: store, child: app);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个坑,如果按照 fluro 提供的文档将应用路由映射至fluro的路由表,使用的方式是 <code>onGenerateRoute: router.generator</code>, 但是这样的话在路由跳转时就无法指定过渡动效了,因此需要改成这样</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onGenerateRoute: (RouteSettings routeSettings) &#123;</span><br><span class="line">  <span class="comment">// 这个方法可以在 router.generator 源码里找到,返回匹配的路由</span></span><br><span class="line">  RouteMatch match = <span class="keyword">this</span>.router.matchRoute(<span class="keyword">null</span>, routeSettings.name, routeSettings: routeSettings, transitionType: TransitionType.inFromRight);</span><br><span class="line">  <span class="keyword">return</span> match.route;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>使用 StoreProvider 容器包裹整个应用入口widget,这样才能在子节点的widget上使用StoreConnector连接store来获取数据状态和派发action</p>
<ul>
<li>接下来应用会进入路由机制,下面是部分路由配置信息</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;dart:core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;package:fluro/fluro.dart&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;package:flutter/material.dart&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;package:cnoder/container/index.dart&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Handler&gt; handlers = &#123;</span><br><span class="line">  <span class="string">&#x27;/&#x27;</span>: <span class="keyword">new</span> Handler(</span><br><span class="line">      handlerFunc: (BuildContext context, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; params) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IndexContainer();</span><br><span class="line">  &#125;),</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>container/index.dart</code> 类似于 react 里面的 HOC,将 store 连接至子widget</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;package:flutter/material.dart&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;package:redux/redux.dart&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;package:flutter_redux/flutter_redux.dart&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../store/root_state.dart&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../store/view_model/index.dart&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../widget/index.dart&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexContainer</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> StoreConnector&lt;RootState, IndexViewModel&gt;(</span><br><span class="line">        converter: (Store&lt;RootState&gt; store) =&gt; IndexViewModel.fromStore(store),</span><br><span class="line">        builder: (BuildContext context, IndexViewModel vm) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> IndexScene(vm: vm);</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>converter 参数相当于在使用 react+redux 技术栈里面的使用 connect 函数包裹组件时的 mapAction 和 mapState 参数,将返回值作为 builder 参数对应的回调函数第二个入参 vm.</p>
<ul>
<li><code>widget/index.dart</code> 为首页的视图widget,通过底部的标签栏切换四个容器widget的显示</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">IndexScene</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 根据登陆状态切换显示</span></span><br><span class="line">  <span class="built_in">List</span> _renderScenes(<span class="built_in">bool</span> isLogined) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> isLogined = widget.vm.auth[<span class="string">&quot;isLogined&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> &lt;Widget&gt;[</span><br><span class="line">      <span class="keyword">new</span> TopicsContainer(vm: widget.vm),</span><br><span class="line">      isLogined ? <span class="keyword">new</span> CollectContainer(vm: widget.vm) : <span class="keyword">new</span> LoginScene(),</span><br><span class="line">      isLogined ? <span class="keyword">new</span> MessageContainer(vm: widget.vm,) : <span class="keyword">new</span> LoginScene(),</span><br><span class="line">      isLogined ? <span class="keyword">new</span> MeContainer(vm: widget.vm,) : <span class="keyword">new</span> LoginScene()</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">bool</span> isLogined = widget.vm.auth[<span class="string">&quot;isLogined&quot;</span>];</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span> scenes = _renderScenes(isLogined);</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">int</span> tabIndex = widget.vm.tabIndex;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Function</span> setTab = widget.vm.selectTab;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">final</span> currentScene = scenes[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 这里保证了初始化widget的服务调用</span></span><br><span class="line">      <span class="keyword">if</span> (currentScene <span class="keyword">is</span> InitializeContainer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentScene.getInitialized() == <span class="keyword">false</span>) &#123;</span><br><span class="line">          currentScene.initialize();</span><br><span class="line">          currentScene.setInitialized();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">        bottomNavigationBar: <span class="keyword">new</span> CupertinoTabBar(</span><br><span class="line">          activeColor: Colors.green,</span><br><span class="line">          backgroundColor: <span class="keyword">const</span> Color(<span class="number">0xFFF7F7F7</span>),</span><br><span class="line">          currentIndex: tabIndex,</span><br><span class="line">          onTap: (<span class="built_in">int</span> i) &#123;</span><br><span class="line">            <span class="keyword">final</span> currentScene = scenes[i];</span><br><span class="line">            <span class="keyword">if</span> (isLogined) &#123;</span><br><span class="line">              <span class="comment">//  这里保证了widget的服务调用在切换时只进行一次</span></span><br><span class="line">              <span class="keyword">if</span> (currentScene <span class="keyword">is</span> InitializeContainer) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentScene.getInitialized() == <span class="keyword">false</span>) &#123;</span><br><span class="line">                  currentScene.initialize();</span><br><span class="line">                  currentScene.setInitialized();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            setTab(i);</span><br><span class="line">          &#125;,</span><br><span class="line">          items: &lt;BottomNavigationBarItem&gt;[</span><br><span class="line">            <span class="keyword">new</span> BottomNavigationBarItem(</span><br><span class="line">              icon: <span class="keyword">new</span> Icon(Icons.home),</span><br><span class="line">              title: <span class="keyword">new</span> Text(<span class="string">&#x27;主题&#x27;</span>),</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> BottomNavigationBarItem(</span><br><span class="line">              icon: <span class="keyword">new</span> Icon(Icons.favorite),</span><br><span class="line">              title: <span class="keyword">new</span> Text(<span class="string">&#x27;收藏&#x27;</span>)</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> BottomNavigationBarItem(</span><br><span class="line">              icon: <span class="keyword">new</span> Icon(Icons.message),</span><br><span class="line">              title: <span class="keyword">new</span> Text(<span class="string">&#x27;消息&#x27;</span>)</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> BottomNavigationBarItem(</span><br><span class="line">              icon: <span class="keyword">new</span> Icon(Icons.person),</span><br><span class="line">              title: <span class="keyword">new</span> Text(<span class="string">&#x27;我的&#x27;</span>)</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 使用层叠widget来包裹视图,同一时间仅一个视图widget可见</span></span><br><span class="line">        body: <span class="keyword">new</span> IndexedStack(</span><br><span class="line">          children: scenes,</span><br><span class="line">          index: tabIndex,</span><br><span class="line">        )</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多同学会有疑问,tabIndex 这个应该只是首页widget的内部数据状态,为何要放到 redux 里去维护?因为我们在子widget里面会去切换页签的选中状态,比如登陆完成以后切换至’我的’这个页签</p>
<ul>
<li>主题视图容器widget,在容器组件里面触发服务调用获取主题数据</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化标志位</span></span><br><span class="line"><span class="built_in">bool</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopicsContainer</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> <span class="keyword">implements</span> <span class="title">InitializeContainer</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> IndexViewModel vm;</span><br><span class="line"></span><br><span class="line">  TopicsContainer(&#123;Key key, <span class="meta">@required</span> <span class="keyword">this</span>.vm&#125;):<span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标记已初始化,防止在首页页签切换时重复调用</span></span><br><span class="line">  <span class="keyword">void</span> setInitialized() &#123;</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取初始化状态</span></span><br><span class="line">  <span class="built_in">bool</span> getInitialized() &#123;</span><br><span class="line">    <span class="keyword">return</span> initialized;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化的操作是调用 redux action 获取主题数据</span></span><br><span class="line">  <span class="keyword">void</span> initialize() &#123;</span><br><span class="line">    vm.fetchTopics();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> StoreConnector&lt;RootState, TopicsViewModel&gt;(</span><br><span class="line">        converter: (Store&lt;RootState&gt; store) =&gt; TopicsViewModel.fromStore(store),</span><br><span class="line">        builder: (BuildContext context, TopicsViewModel vm) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> TopicsScene(vm: vm);</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主题视图widget,顶部四个页签用来切换显示四个主题分类</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopicsState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TopicsScene</span>&gt; <span class="title">with</span> <span class="title">TickerProviderStateMixin</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="keyword">final</span> topicsOfCategory = widget.vm.topicsOfCategory;</span><br><span class="line"></span><br><span class="line">    _tabs = &lt;Tab&gt;[];</span><br><span class="line">    <span class="comment">// 初始化顶部页签栏</span></span><br><span class="line">    topicsOfCategory.forEach((k, v) &#123;</span><br><span class="line">      _tabs.add(<span class="keyword">new</span> Tab(</span><br><span class="line">        text: v[<span class="string">&quot;label&quot;</span>]</span><br><span class="line">      ));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 初始化 TabBar 和 TabBarView 的控制器</span></span><br><span class="line">    _tabController  = <span class="keyword">new</span> TabController(</span><br><span class="line">      length: _tabs.length,</span><br><span class="line">      vsync: <span class="keyword">this</span> <span class="comment">// _tabController 作为属性的类必须通过 TickerProviderStateMixin 扩展</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 页签切换事件监听</span></span><br><span class="line">    _onTabChange = () &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给页签控制器增加一个事件监听器,监听页签切换事件</span></span><br><span class="line">    _tabController.addListener(_onTabChange);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    <span class="comment">// 类销毁之前移除页签控制器的事件监听</span></span><br><span class="line">    _tabController.removeListener(_onTabChange);</span><br><span class="line">    <span class="comment">// 销毁页签控制器</span></span><br><span class="line">    _tabController.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">      <span class="built_in">bool</span> isLoading = widget.vm.isLoading;</span><br><span class="line">      <span class="built_in">Map</span> topicsOfCategory = widget.vm.topicsOfCategory;</span><br><span class="line">      FetchTopics fetchTopics = widget.vm.fetchTopics;</span><br><span class="line">      ResetTopics resetTopics = widget.vm.resetTopics;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 循环显示分类下的主题列表</span></span><br><span class="line">      <span class="built_in">List</span>&lt;Widget&gt; _renderTabView() &#123;</span><br><span class="line">        <span class="keyword">final</span> _tabViews = &lt;Widget&gt;[];</span><br><span class="line">        topicsOfCategory.forEach((k, category) &#123;</span><br><span class="line">          <span class="built_in">bool</span> isFetched = topicsOfCategory[k][<span class="string">&quot;isFetched&quot;</span>];</span><br><span class="line">          <span class="comment">// 如果该分类下的主题列表未初始化先渲染一个加载指示</span></span><br><span class="line">          _tabViews.add(!isFetched ? _renderLoading(context) :</span><br><span class="line">          <span class="comment">// 使用 pull_to_refresh 包提供的下拉刷新和上来加载功能</span></span><br><span class="line">          <span class="keyword">new</span> SmartRefresher(</span><br><span class="line">            enablePullDown: <span class="keyword">true</span>,</span><br><span class="line">            enablePullUp: <span class="keyword">true</span>,</span><br><span class="line">            onRefresh: _onRefresh(k),</span><br><span class="line">            controller: _controller,</span><br><span class="line">            child: <span class="keyword">new</span> ListView.builder(</span><br><span class="line">              physics: <span class="keyword">const</span> NeverScrollableScrollPhysics(),</span><br><span class="line">              shrinkWrap: <span class="keyword">true</span>,</span><br><span class="line">              itemCount: topicsOfCategory[k][<span class="string">&quot;list&quot;</span>].length,</span><br><span class="line">              itemBuilder: (BuildContext context, <span class="built_in">int</span> i) =&gt; _renderRow(context, topicsOfCategory[k][<span class="string">&quot;list&quot;</span>][i]),</span><br><span class="line">            ),</span><br><span class="line">          ));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> _tabViews;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 使用 ListTile 渲染列表中的每一行</span></span><br><span class="line">      Widget _renderRow(BuildContext context, Topic topic) &#123;</span><br><span class="line">      ListTile title = <span class="keyword">new</span> ListTile(</span><br><span class="line">        leading: <span class="keyword">new</span> SizedBox(</span><br><span class="line">          width: <span class="number">30.0</span>,</span><br><span class="line">          height: <span class="number">30.0</span>,</span><br><span class="line">          <span class="comment">// 使用 cached_network_image 提供支持缓存和占位图的功能显示头像</span></span><br><span class="line">          child: <span class="keyword">new</span> CachedNetworkImage(</span><br><span class="line">            imageUrl: topic.authorAvatar.startsWith(<span class="string">&#x27;//&#x27;</span>) ? <span class="string">&#x27;http:<span class="subst">$&#123;topic.authorAvatar&#125;</span>&#x27;</span> : topic.authorAvatar,</span><br><span class="line">            placeholder: <span class="keyword">new</span> Image.asset(<span class="string">&#x27;asset/image/cnoder_avatar.png&#x27;</span>),</span><br><span class="line">            errorWidget: <span class="keyword">new</span> Icon(Icons.error),</span><br><span class="line">          )</span><br><span class="line">        ),</span><br><span class="line">        title: <span class="keyword">new</span> Text(topic.authorName),</span><br><span class="line">        subtitle: <span class="keyword">new</span> Row(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="keyword">new</span> Text(topic.lastReplyAt)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        trailing: <span class="keyword">new</span> Text(<span class="string">&#x27;<span class="subst">$&#123;topic.replyCount&#125;</span>/<span class="subst">$&#123;topic.visitCount&#125;</span>&#x27;</span>),</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> InkWell(</span><br><span class="line">        <span class="comment">// 点击后跳转至主题详情</span></span><br><span class="line">        onTap: () =&gt; Navigator.of(context).pushNamed(<span class="string">&#x27;/topic/<span class="subst">$&#123;topic.id&#125;</span>&#x27;</span>),</span><br><span class="line">        child: <span class="keyword">new</span> Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            title,</span><br><span class="line">            <span class="keyword">new</span> Container(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">              alignment: Alignment.centerLeft,</span><br><span class="line">              child: <span class="keyword">new</span> Text(topic.title),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">          brightness: Brightness.dark,</span><br><span class="line">          elevation: <span class="number">0.0</span>,</span><br><span class="line">          titleSpacing: <span class="number">0.0</span>,</span><br><span class="line">          bottom: <span class="keyword">null</span>,</span><br><span class="line">          <span class="comment">// 顶部显示页签栏</span></span><br><span class="line">          title: <span class="keyword">new</span> Align(</span><br><span class="line">            alignment: Alignment.bottomCenter,</span><br><span class="line">            child: <span class="keyword">new</span> TabBar(</span><br><span class="line">              labelColor: Colors.white,</span><br><span class="line">              tabs: _tabs,</span><br><span class="line">              controller: _tabController,</span><br><span class="line">            )</span><br><span class="line">          )</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 主体区域显示页签内容</span></span><br><span class="line">        body: <span class="keyword">new</span> TabBarView(</span><br><span class="line">          controller: _tabController,</span><br><span class="line">          children: _renderTabView(),</span><br><span class="line">        )</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据状态"><a href="#数据状态" class="headerlink" title="数据状态"></a>数据状态</h2><ul>
<li><code>store/view_model/topics.dart</code> 视图映射模型定义</li>
</ul>
<p>通过视图映射模型将 store 里面的 state 和 action 传递给视图widget,<br>在上面的主题容器widget里面我们通过 <code>vm.fetchTopics</code> 方法获取主题数据, 这个方法是在 TopicsViewModel 这个<br>store 映射模型里定义的</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopicsViewModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span> topicsOfCategory;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isLoading;</span><br><span class="line">  <span class="keyword">final</span> FetchTopics fetchTopics;</span><br><span class="line">  <span class="keyword">final</span> ResetTopics resetTopics;</span><br><span class="line"></span><br><span class="line">  TopicsViewModel(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.topicsOfCategory, </span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.isLoading, </span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.fetchTopics, </span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.resetTopics</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> TopicsViewModel fromStore(Store&lt;RootState&gt; store) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TopicsViewModel(</span><br><span class="line">      <span class="comment">// 映射分类主题列表</span></span><br><span class="line">      topicsOfCategory: store.state.topicsOfCategory,</span><br><span class="line">      <span class="comment">// 映射加载状态</span></span><br><span class="line">      isLoading: store.state.isLoading,</span><br><span class="line">      <span class="comment">// 获取主题数据 action 的包装方法</span></span><br><span class="line">      fetchTopics: (&#123;<span class="built_in">int</span> currentPage = <span class="number">1</span>, <span class="built_in">String</span> category = <span class="string">&#x27;&#x27;</span>, <span class="built_in">Function</span> afterFetched = _noop&#125;) &#123;</span><br><span class="line">        <span class="comment">// 通过 isLoading 数据状态的变更来切换widget的加载指示器的显示</span></span><br><span class="line">        store.dispatch(<span class="keyword">new</span> ToggleLoading(<span class="keyword">true</span>));</span><br><span class="line">        <span class="comment">// 触发获取主题数据的action,将当前页,分类名,以及调用成功的回调函数传递给action</span></span><br><span class="line">        store.dispatch(<span class="keyword">new</span> RequestTopics(currentPage: currentPage, category: category, afterFetched: afterFetched));</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 刷新主题数据的包装方法</span></span><br><span class="line">      resetTopics: (&#123;<span class="meta">@required</span> <span class="built_in">String</span> category, <span class="meta">@required</span> <span class="built_in">Function</span> afterFetched&#125;) &#123;</span><br><span class="line">        store.dispatch(<span class="keyword">new</span> RequestTopics(currentPage: <span class="number">1</span>, category: category, afterFetched: afterFetched));</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里增加了一个调用成功的回调函数给 action,是因为需要在 http 服务调用完成以后控制主题视图widget里面 SmartRefresher 这个widget 状态的切换(重置加载指示等等)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> _onRefresh = (<span class="built_in">String</span> category) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">bool</span> up) &#123;</span><br><span class="line">      <span class="comment">// 如果是上拉加载更多</span></span><br><span class="line">      <span class="keyword">if</span> (!up) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLoading) &#123;</span><br><span class="line">          _controller.sendBack(<span class="keyword">false</span>, RefreshStatus.idle);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fetchTopics(</span><br><span class="line">          currentPage: topicsOfCategory[category][<span class="string">&quot;currentPage&quot;</span>] + <span class="number">1</span>,</span><br><span class="line">          category: category,</span><br><span class="line">          afterFetched: () &#123;</span><br><span class="line">            <span class="comment">// 上拉加载更多指示器复位</span></span><br><span class="line">            _controller.sendBack(<span class="keyword">false</span>, RefreshStatus.idle);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      <span class="comment">// 如果是下拉刷新</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resetTopics(</span><br><span class="line">          category: category,</span><br><span class="line">          afterFetched: () &#123;</span><br><span class="line">            <span class="comment">// 下拉刷新指示器复位</span></span><br><span class="line">            _controller.sendBack(<span class="keyword">true</span>, RefreshStatus.completed);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>store/action/topic.dart</code> action 定义</li>
</ul>
<p>在 flutter 中以类的方式来定义 action 的,这一点与我们在 react 中使用 redux 有点不同</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送主题列表请求的 action</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestTopics</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前页</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> currentPage;</span><br><span class="line">  <span class="comment">// 分类</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> category;</span><br><span class="line">  <span class="comment">// 请求完成的回调</span></span><br><span class="line">  <span class="keyword">final</span> VoidCallback afterFetched;</span><br><span class="line"></span><br><span class="line">  RequestTopics(&#123;<span class="keyword">this</span>.currentPage = <span class="number">1</span>, <span class="keyword">this</span>.category = <span class="string">&quot;&quot;</span>, <span class="meta">@required</span> <span class="keyword">this</span>.afterFetched&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应主题列表请求的 action</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResponseTopics</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Topic&gt; topics;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> currentPage;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> category;</span><br><span class="line"></span><br><span class="line">  ResponseTopics(<span class="keyword">this</span>.currentPage, <span class="keyword">this</span>.category, <span class="keyword">this</span>.topics);</span><br><span class="line"></span><br><span class="line">  ResponseTopics.failed() : <span class="keyword">this</span>(<span class="number">1</span>, <span class="string">&quot;&quot;</span>, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>epic 定义,redux epic 可以看成是 action 的一个调度器,虽然 flutter 里的redux 也有 redux_thunk 中间件,但是 epic 这种基于流的调度中间件使得业务逻辑更加优雅</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">dynamic</span>&gt; fetchTopicsEpic(</span><br><span class="line">    Stream&lt;<span class="built_in">dynamic</span>&gt; actions, EpicStore&lt;RootState&gt; store) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(actions)</span><br><span class="line">      <span class="comment">// 过滤特定请求</span></span><br><span class="line">      .ofType(<span class="keyword">new</span> TypeToken&lt;RequestTopics&gt;())</span><br><span class="line">      .flatMap((action) &#123;</span><br><span class="line">        <span class="comment">// 通过异步生成器来构建一个流</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Observable(() <span class="keyword">async</span>* &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 发送获取主题列表的 http 请求</span></span><br><span class="line">            <span class="keyword">final</span> ret = <span class="keyword">await</span> http.<span class="keyword">get</span>(<span class="string">&quot;<span class="subst">$&#123;apis[<span class="string">&#x27;topics&#x27;</span>]&#125;</span>?page=<span class="subst">$&#123;action.currentPage&#125;</span>&amp;limit=6&amp;tab=<span class="subst">$&#123;action.category&#125;</span>&amp;mdrender=false&quot;</span>);</span><br><span class="line">            <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; result = json.decode(ret.body);</span><br><span class="line">            <span class="built_in">List</span>&lt;Topic&gt; topics = [];</span><br><span class="line">            result[<span class="string">&#x27;data&#x27;</span>].forEach((v) &#123;</span><br><span class="line">              topics.add(<span class="keyword">new</span> Topic.fromJson(v));</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 触发请求完成的回调,就是我们上面提到的 SmartRefresher widget 的复位</span></span><br><span class="line">            action.afterFetched();</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">new</span> ResponseTopics(action.currentPage, action.category, topics);</span><br><span class="line">          &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="built_in">print</span>(err);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">new</span> ResponseTopicsFailed(err);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 刷新数据状态复位</span></span><br><span class="line">          <span class="keyword">yield</span> <span class="keyword">new</span> ToggleLoading(<span class="keyword">false</span>);</span><br><span class="line">        &#125; ());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在接收到请求响应后,通过 <code>Topic.fromJson</code> 这个指定类构造器来创建主题列表,这个方法定义在 <code>store/model/topic.dart</code>里面</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Topic.fromJson(<span class="keyword">final</span> <span class="built_in">Map</span> map):</span><br><span class="line">    <span class="keyword">this</span>.id = map[<span class="string">&quot;id&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.authorName = map[<span class="string">&quot;author&quot;</span>][<span class="string">&quot;loginname&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.authorAvatar = map[<span class="string">&quot;author&quot;</span>][<span class="string">&quot;avatar_url&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.title = map[<span class="string">&quot;title&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.tag = map[<span class="string">&quot;tab&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.content = map[<span class="string">&quot;content&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.createdAt = fromNow(map[<span class="string">&quot;create_at&quot;</span>]),</span><br><span class="line">    <span class="keyword">this</span>.lastReplyAt = fromNow(map[<span class="string">&quot;last_reply_at&quot;</span>]),</span><br><span class="line">    <span class="keyword">this</span>.replyCount = map[<span class="string">&quot;reply_count&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.visitCount = map[<span class="string">&quot;visit_count&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.top = map[<span class="string">&quot;top&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.isCollect = map[<span class="string">&quot;is_collect&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.replies = formatedReplies(map[<span class="string">&#x27;replies&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>store/reducer/topic.dart</code>, 通过主题列表的 reducer 来变更 store 里面的数据状态</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Reducer&lt;<span class="built_in">Map</span>&gt; topicsReducer = combineReducers([</span><br><span class="line">  <span class="comment">// 通过指定 action 类型来拆分</span></span><br><span class="line">  <span class="keyword">new</span> TypedReducer&lt;<span class="built_in">Map</span>, ClearTopic&gt;(_clearTopic),</span><br><span class="line">  <span class="keyword">new</span> TypedReducer&lt;<span class="built_in">Map</span>, RequestTopics&gt;(_requestTopics),</span><br><span class="line">  <span class="keyword">new</span> TypedReducer&lt;<span class="built_in">Map</span>, ResponseTopics&gt;(_responseTopics)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空主题列表</span></span><br><span class="line"><span class="built_in">Map</span> _clearTopic(<span class="built_in">Map</span> state, ClearTopic action) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span> _requestTopics(<span class="built_in">Map</span> state, RequestTopics action) &#123;</span><br><span class="line">  <span class="built_in">Map</span> topicsOfTopics = &#123;&#125;;</span><br><span class="line">  state.forEach((k, v) &#123;</span><br><span class="line">    <span class="keyword">final</span> _v = <span class="keyword">new</span> <span class="built_in">Map</span>.from(v);</span><br><span class="line">    <span class="keyword">if</span> (action.category == k) &#123;</span><br><span class="line">      <span class="comment">// 通过 isFetched 标志位来防止分类页面切换时重复请求</span></span><br><span class="line">      _v[<span class="string">&quot;isFetched&quot;</span>] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    topicsOfTopics[k] = _v;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> topicsOfTopics;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span> _responseTopics(<span class="built_in">Map</span> state, ResponseTopics action) &#123;</span><br><span class="line">  <span class="built_in">Map</span> topicsOfCategory = &#123;&#125;;</span><br><span class="line">  state.forEach((k, v) &#123;</span><br><span class="line">    <span class="built_in">Map</span> _v = &#123;&#125;;</span><br><span class="line">    _v.addAll(v);</span><br><span class="line">    <span class="keyword">if</span> (k == action.category) &#123;</span><br><span class="line">      <span class="built_in">List</span> _list = [];</span><br><span class="line">      <span class="comment">// 上拉加载更多时</span></span><br><span class="line">      <span class="keyword">if</span> (_v[<span class="string">&#x27;currentPage&#x27;</span>] &lt; action.currentPage) &#123;</span><br><span class="line">        _list.addAll(_v[<span class="string">&quot;list&quot;</span>]);</span><br><span class="line">        _list.addAll(action.topics);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 下拉刷新时</span></span><br><span class="line">      <span class="keyword">if</span> (action.currentPage == <span class="number">1</span>) &#123;</span><br><span class="line">        _list.addAll(action.topics);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 通过 isFetched 标志位来防止分类页面切换时重复请求</span></span><br><span class="line">      _v[<span class="string">&quot;isFetched&quot;</span>] = <span class="keyword">true</span>;</span><br><span class="line">      _v[<span class="string">&quot;list&quot;</span>] = _list;</span><br><span class="line">      _v[<span class="string">&quot;currentPage&quot;</span>] = action.currentPage;</span><br><span class="line">    &#125;</span><br><span class="line">    topicsOfCategory[k] = _v;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> topicsOfCategory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>store/reducer/root.dart</code> 的 rootReducer 里进行合并</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">RootState rootReducer(RootState state, action) &#123;</span><br><span class="line">  <span class="comment">// 处理从持久化存储里加载数据状态</span></span><br><span class="line">  <span class="keyword">if</span> (action <span class="keyword">is</span> PersistLoadedAction&lt;RootState&gt;) &#123;</span><br><span class="line">    <span class="keyword">return</span> action.state ?? state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将 state 里的数据状态对应到子 reducer</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RootState(</span><br><span class="line">    tabIndex: tabReducer(state.tabIndex, action),</span><br><span class="line">    auth:  loginReducer(state.auth, action),</span><br><span class="line">    isLoading: loadingReducer(state.isLoading, action),</span><br><span class="line">    topicsOfCategory: topicsReducer(state.topicsOfCategory, action),</span><br><span class="line">    topic: topicReducer(state.topic, action),</span><br><span class="line">    me: meReducer(state.me, action),</span><br><span class="line">    collects: collectsReducer(state.collects, action),</span><br><span class="line">    messages: messagesReducer(state.messages, action)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>store/index.dart</code> store 的初始化入口,在我们上面的入口widget里面使用 <code>StoreProvider</code> 容器包裹的时候传递</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并 epic 获得根 epic 提供给 epic 中间件调用</span></span><br><span class="line"><span class="keyword">final</span> epic = combineEpics([</span><br><span class="line">  doLoginEpic, </span><br><span class="line">  fetchTopicsEpic, fetchTopicEpic, </span><br><span class="line">  fetchMeEpic,</span><br><span class="line">  fetchCollectsEpic,</span><br><span class="line">  fetchMessagesEpic,</span><br><span class="line">  fetchMessageCountEpic,</span><br><span class="line">  markAllAsReadEpic,</span><br><span class="line">  markAsReadEpic,</span><br><span class="line">  createReplyEpic,</span><br><span class="line">  saveTopicEpic,</span><br><span class="line">  createTopicEpic,</span><br><span class="line">  toggleCollectEpic,</span><br><span class="line">  likeReplyEpic,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化持久化中间件存储容器</span></span><br><span class="line"><span class="keyword">final</span> persistor = Persistor&lt;RootState&gt;(</span><br><span class="line">  storage: FlutterStorage(<span class="string">&#x27;cnoder&#x27;</span>),</span><br><span class="line">  decoder: RootState.fromJson,</span><br><span class="line">  debug: <span class="keyword">true</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 store</span></span><br><span class="line"><span class="keyword">final</span> store = <span class="keyword">new</span> Store&lt;RootState&gt;(rootReducer,</span><br><span class="line">  initialState: <span class="keyword">new</span> RootState(), middleware: [</span><br><span class="line">    <span class="keyword">new</span> LoggingMiddleware.printer(), </span><br><span class="line">    <span class="keyword">new</span> EpicMiddleware(epic),</span><br><span class="line">    persistor.createMiddleware()</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>这里有个小坑,持久化存储中间件 redux_persist 的文档上加载中间件的方式为</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> store = <span class="keyword">new</span> Store&lt;AppState&gt;(</span><br><span class="line">  reducer,</span><br><span class="line">  initialState: <span class="keyword">new</span> AppState(),</span><br><span class="line">  middleware: [persistor.createMiddleware()],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>但是这样处理的话,在每个业务 action 触发的时候,都会触发持久化的操作,而这在很多场景下是不必要的,比如在我们的应用中只需要保存的用户身份令牌,所以只需要在触发登陆和登出 action 的时候执行持久化的操作,因此加载中间件的方式需要做如下改动</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> persistMiddleware(Store store, <span class="built_in">dynamic</span> action, NextDispatcher next) &#123;</span><br><span class="line">  next(action);</span><br><span class="line">  <span class="comment">// 仅处理登陆和登出操作</span></span><br><span class="line">  <span class="keyword">if</span> (action <span class="keyword">is</span> FinishLogin || action <span class="keyword">is</span> Logout) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      persistor.save(store);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 store</span></span><br><span class="line"><span class="keyword">final</span> store = <span class="keyword">new</span> Store&lt;RootState&gt;(rootReducer,</span><br><span class="line">  initialState: <span class="keyword">new</span> RootState(), middleware: [</span><br><span class="line">    <span class="keyword">new</span> LoggingMiddleware.printer(), </span><br><span class="line">    <span class="keyword">new</span> EpicMiddleware(epic),</span><br><span class="line">    persistMiddleware</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>应用的视图层和数据状态处理还是跟使用 React-Native 开发中使用 redux 技术栈的方式差不多,虽然整体目录结构有点繁琐,但是业务逻辑清晰明了,在后续功能扩展和维护的时候还是带来不少的方便,唯一遗憾的是因为 flutter 系统架构的问题,还没有一个针对 flutter 的 redux devtools,这一点还是蛮影响开发效率的</p>
<p>完整的项目源码请关注github仓库: <a href="https://github.com/ali322/cnoder">cnoder</a>,欢迎 star 和 PR,对 flutter 理解的不深,还望各位对本文中的不足之处批评指正</p>
<p><strong><img src="https://juejin.im/post/5b43187ff265da0f491b87e7" alt="从 0 到 1：我的 Flutter 技术实践 | 掘金技术征文，征文活动整在进行中"></strong></p>
<h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>之前在学会 React-Native 后写了一个 cnodejs社区的客户端 <a href="https://github.com/ali322/CNodeRN">CNodeRN</a>,前阵子了解了下 flutter, 感觉是移动应用开发的未来趋势,便有了迁移至 flutter 技术栈的想法, 然后就有了 <a href="https://github.com/ali322/cnoder">CNoder</a> 这个项目, 也算是对数周 flutter 的一个学习实践吧</p>
<h2 id="安装和初始化-1"><a href="#安装和初始化-1" class="headerlink" title="安装和初始化"></a>安装和初始化</h2><p>跟着官方的<a href="https://flutter.io/setup-macos/">安装说明</a>一步一步往下走,还是挺顺利的,唯一不同的就是增加了镜像设置这一步, 打开 <code>~/.zhsrc</code>, 末尾增加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> <span class="comment">## flutter</span></span><br><span class="line">125 <span class="built_in">export</span> PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">126 <span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br><span class="line">127 <span class="built_in">export</span> PATH=<span class="variable">$HOME</span>/flutter/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<p>然后执行 <code>flutter doctor</code> 检查环境是否正常,一切顺利的话就可以初始化项目了,我使用的编辑器是 <code>vscode</code>, 通过命令窗口运行命令 <code>Flutter: New Project</code> 即可</p>
<h2 id="项目目录结构-1"><a href="#项目目录结构-1" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><p>源码都位于 <code>lib</code> 目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">|-- config/</span><br><span class="line">    |-- api.dart // http api 调用接口地址配置</span><br><span class="line">|-- common/</span><br><span class="line">    |-- helper.dart // 工具函数</span><br><span class="line">|-- route/</span><br><span class="line">    |-- handler.dart // 路由配置文件</span><br><span class="line">|-- store/</span><br><span class="line">    |-- action/  // redux action 目录</span><br><span class="line">    |-- epic/   // redux_epic 配置目录</span><br><span class="line">    |-- reducer/ // redux reducer 目录</span><br><span class="line">    |-- model/ // 模型目录</span><br><span class="line">    |-- view_model/ // store 映射模型目录</span><br><span class="line">    |-- root_state.dart // 全局 state</span><br><span class="line">    |-- index.dart // store 初始入口</span><br><span class="line">|-- container/  // 连接 store 的容器目录</span><br><span class="line">|-- widget/ // 视图 widget 目录</span><br><span class="line">main.dart // 入口文件</span><br><span class="line">app.dart // 入口widget</span><br></pre></td></tr></table></figure>

<h2 id="功能模块-1"><a href="#功能模块-1" class="headerlink" title="功能模块"></a>功能模块</h2><ul>
<li>入口文件: main.dart, 逻辑很简单就不描述了</li>
<li>入口widget: app.dart文件</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化路由插件</span></span><br><span class="line">  <span class="keyword">final</span> Router router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">  App() &#123;</span><br><span class="line">    <span class="comment">// 从持久化存储里加载数据状态,这里用来存储用户的身份令牌信息</span></span><br><span class="line">    persistor.load(store);</span><br><span class="line">    <span class="comment">// 404处理</span></span><br><span class="line">    router.notFoundHandler = notFoundHandler;</span><br><span class="line">    <span class="comment">// 应用路由配置</span></span><br><span class="line">    handlers.forEach((<span class="built_in">String</span> path,Handler handler) &#123;</span><br><span class="line">      router.define(path, handler: handler);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">final</span> app = <span class="keyword">new</span> MaterialApp(</span><br><span class="line">        title: <span class="string">&#x27;CNoder&#x27;</span>,</span><br><span class="line">        <span class="comment">// 禁用右上角的 debug 标志</span></span><br><span class="line">        debugShowCheckedModeBanner: <span class="keyword">false</span>,</span><br><span class="line">        theme: <span class="keyword">new</span> ThemeData(</span><br><span class="line">          primarySwatch: Colors.lightGreen,</span><br><span class="line">          <span class="comment">// 定义全局图标主题</span></span><br><span class="line">          iconTheme: <span class="keyword">new</span> IconThemeData(</span><br><span class="line">            color: Color(<span class="number">0xFF666666</span>)</span><br><span class="line">          ),</span><br><span class="line">          <span class="comment">// 定义全局文本主题</span></span><br><span class="line">          textTheme: <span class="keyword">new</span> TextTheme(</span><br><span class="line">            body1: <span class="keyword">new</span> TextStyle(color: Color(<span class="number">0xFF333333</span>), fontSize: <span class="number">14.0</span>)</span><br><span class="line">          )</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 将 应用的路由映射至 fluro 的路由表里面去</span></span><br><span class="line">        onGenerateRoute: router.generator</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span>  <span class="keyword">new</span> StoreProvider&lt;RootState&gt;(store: store, child: app);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个坑,如果按照 fluro 提供的文档将应用路由映射至fluro的路由表,使用的方式是 <code>onGenerateRoute: router.generator</code>, 但是这样的话在路由跳转时就无法指定过渡动效了,因此需要改成这样</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">onGenerateRoute: (RouteSettings routeSettings) &#123;</span><br><span class="line">  <span class="comment">// 这个方法可以在 router.generator 源码里找到,返回匹配的路由</span></span><br><span class="line">  RouteMatch match = <span class="keyword">this</span>.router.matchRoute(<span class="keyword">null</span>, routeSettings.name, routeSettings: routeSettings, transitionType: TransitionType.inFromRight);</span><br><span class="line">  <span class="keyword">return</span> match.route;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>使用 StoreProvider 容器包裹整个应用入口widget,这样才能在子节点的widget上使用StoreConnector连接store来获取数据状态和派发action</p>
<ul>
<li>接下来应用会进入路由机制,下面是部分路由配置信息</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;dart:core&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;package:fluro/fluro.dart&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;package:flutter/material.dart&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;package:cnoder/container/index.dart&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Handler&gt; handlers = &#123;</span><br><span class="line">  <span class="string">&#x27;/&#x27;</span>: <span class="keyword">new</span> Handler(</span><br><span class="line">      handlerFunc: (BuildContext context, <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; params) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IndexContainer();</span><br><span class="line">  &#125;),</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>container/index.dart</code> 类似于 react 里面的 HOC,将 store 连接至子widget</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;package:flutter/material.dart&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;package:redux/redux.dart&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;package:flutter_redux/flutter_redux.dart&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../store/root_state.dart&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../store/view_model/index.dart&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;../widget/index.dart&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexContainer</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> StoreConnector&lt;RootState, IndexViewModel&gt;(</span><br><span class="line">        converter: (Store&lt;RootState&gt; store) =&gt; IndexViewModel.fromStore(store),</span><br><span class="line">        builder: (BuildContext context, IndexViewModel vm) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> IndexScene(vm: vm);</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>converter 参数相当于在使用 react+redux 技术栈里面的使用 connect 函数包裹组件时的 mapAction 和 mapState 参数,将返回值作为 builder 参数对应的回调函数第二个入参 vm.</p>
<ul>
<li><code>widget/index.dart</code> 为首页的视图widget,通过底部的标签栏切换四个容器widget的显示</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">IndexScene</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 根据登陆状态切换显示</span></span><br><span class="line">  <span class="built_in">List</span> _renderScenes(<span class="built_in">bool</span> isLogined) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="built_in">bool</span> isLogined = widget.vm.auth[<span class="string">&quot;isLogined&quot;</span>];</span><br><span class="line">    <span class="keyword">return</span> &lt;Widget&gt;[</span><br><span class="line">      <span class="keyword">new</span> TopicsContainer(vm: widget.vm),</span><br><span class="line">      isLogined ? <span class="keyword">new</span> CollectContainer(vm: widget.vm) : <span class="keyword">new</span> LoginScene(),</span><br><span class="line">      isLogined ? <span class="keyword">new</span> MessageContainer(vm: widget.vm,) : <span class="keyword">new</span> LoginScene(),</span><br><span class="line">      isLogined ? <span class="keyword">new</span> MeContainer(vm: widget.vm,) : <span class="keyword">new</span> LoginScene()</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">bool</span> isLogined = widget.vm.auth[<span class="string">&quot;isLogined&quot;</span>];</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">List</span> scenes = _renderScenes(isLogined);</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">int</span> tabIndex = widget.vm.tabIndex;</span><br><span class="line">      <span class="keyword">final</span> <span class="built_in">Function</span> setTab = widget.vm.selectTab;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">final</span> currentScene = scenes[<span class="number">0</span>];</span><br><span class="line">      <span class="comment">// 这里保证了初始化widget的服务调用</span></span><br><span class="line">      <span class="keyword">if</span> (currentScene <span class="keyword">is</span> InitializeContainer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentScene.getInitialized() == <span class="keyword">false</span>) &#123;</span><br><span class="line">          currentScene.initialize();</span><br><span class="line">          currentScene.setInitialized();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">        bottomNavigationBar: <span class="keyword">new</span> CupertinoTabBar(</span><br><span class="line">          activeColor: Colors.green,</span><br><span class="line">          backgroundColor: <span class="keyword">const</span> Color(<span class="number">0xFFF7F7F7</span>),</span><br><span class="line">          currentIndex: tabIndex,</span><br><span class="line">          onTap: (<span class="built_in">int</span> i) &#123;</span><br><span class="line">            <span class="keyword">final</span> currentScene = scenes[i];</span><br><span class="line">            <span class="keyword">if</span> (isLogined) &#123;</span><br><span class="line">              <span class="comment">//  这里保证了widget的服务调用在切换时只进行一次</span></span><br><span class="line">              <span class="keyword">if</span> (currentScene <span class="keyword">is</span> InitializeContainer) &#123;</span><br><span class="line">                <span class="keyword">if</span> (currentScene.getInitialized() == <span class="keyword">false</span>) &#123;</span><br><span class="line">                  currentScene.initialize();</span><br><span class="line">                  currentScene.setInitialized();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            setTab(i);</span><br><span class="line">          &#125;,</span><br><span class="line">          items: &lt;BottomNavigationBarItem&gt;[</span><br><span class="line">            <span class="keyword">new</span> BottomNavigationBarItem(</span><br><span class="line">              icon: <span class="keyword">new</span> Icon(Icons.home),</span><br><span class="line">              title: <span class="keyword">new</span> Text(<span class="string">&#x27;主题&#x27;</span>),</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> BottomNavigationBarItem(</span><br><span class="line">              icon: <span class="keyword">new</span> Icon(Icons.favorite),</span><br><span class="line">              title: <span class="keyword">new</span> Text(<span class="string">&#x27;收藏&#x27;</span>)</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> BottomNavigationBarItem(</span><br><span class="line">              icon: <span class="keyword">new</span> Icon(Icons.message),</span><br><span class="line">              title: <span class="keyword">new</span> Text(<span class="string">&#x27;消息&#x27;</span>)</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> BottomNavigationBarItem(</span><br><span class="line">              icon: <span class="keyword">new</span> Icon(Icons.person),</span><br><span class="line">              title: <span class="keyword">new</span> Text(<span class="string">&#x27;我的&#x27;</span>)</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 使用层叠widget来包裹视图,同一时间仅一个视图widget可见</span></span><br><span class="line">        body: <span class="keyword">new</span> IndexedStack(</span><br><span class="line">          children: scenes,</span><br><span class="line">          index: tabIndex,</span><br><span class="line">        )</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多同学会有疑问,tabIndex 这个应该只是首页widget的内部数据状态,为何要放到 redux 里去维护?因为我们在子widget里面会去切换页签的选中状态,比如登陆完成以后切换至’我的’这个页签</p>
<ul>
<li>主题视图容器widget,在容器组件里面触发服务调用获取主题数据</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化标志位</span></span><br><span class="line"><span class="built_in">bool</span> initialized = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopicsContainer</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> <span class="keyword">implements</span> <span class="title">InitializeContainer</span></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> IndexViewModel vm;</span><br><span class="line"></span><br><span class="line">  TopicsContainer(&#123;Key key, <span class="meta">@required</span> <span class="keyword">this</span>.vm&#125;):<span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标记已初始化,防止在首页页签切换时重复调用</span></span><br><span class="line">  <span class="keyword">void</span> setInitialized() &#123;</span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取初始化状态</span></span><br><span class="line">  <span class="built_in">bool</span> getInitialized() &#123;</span><br><span class="line">    <span class="keyword">return</span> initialized;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化的操作是调用 redux action 获取主题数据</span></span><br><span class="line">  <span class="keyword">void</span> initialize() &#123;</span><br><span class="line">    vm.fetchTopics();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> StoreConnector&lt;RootState, TopicsViewModel&gt;(</span><br><span class="line">        converter: (Store&lt;RootState&gt; store) =&gt; TopicsViewModel.fromStore(store),</span><br><span class="line">        builder: (BuildContext context, TopicsViewModel vm) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> TopicsScene(vm: vm);</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主题视图widget,顶部四个页签用来切换显示四个主题分类</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopicsState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">TopicsScene</span>&gt; <span class="title">with</span> <span class="title">TickerProviderStateMixin</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="keyword">final</span> topicsOfCategory = widget.vm.topicsOfCategory;</span><br><span class="line"></span><br><span class="line">    _tabs = &lt;Tab&gt;[];</span><br><span class="line">    <span class="comment">// 初始化顶部页签栏</span></span><br><span class="line">    topicsOfCategory.forEach((k, v) &#123;</span><br><span class="line">      _tabs.add(<span class="keyword">new</span> Tab(</span><br><span class="line">        text: v[<span class="string">&quot;label&quot;</span>]</span><br><span class="line">      ));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 初始化 TabBar 和 TabBarView 的控制器</span></span><br><span class="line">    _tabController  = <span class="keyword">new</span> TabController(</span><br><span class="line">      length: _tabs.length,</span><br><span class="line">      vsync: <span class="keyword">this</span> <span class="comment">// _tabController 作为属性的类必须通过 TickerProviderStateMixin 扩展</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 页签切换事件监听</span></span><br><span class="line">    _onTabChange = () &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给页签控制器增加一个事件监听器,监听页签切换事件</span></span><br><span class="line">    _tabController.addListener(_onTabChange);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">    <span class="comment">// 类销毁之前移除页签控制器的事件监听</span></span><br><span class="line">    _tabController.removeListener(_onTabChange);</span><br><span class="line">    <span class="comment">// 销毁页签控制器</span></span><br><span class="line">    _tabController.dispose();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">    Widget build(BuildContext context) &#123;</span><br><span class="line">      <span class="built_in">bool</span> isLoading = widget.vm.isLoading;</span><br><span class="line">      <span class="built_in">Map</span> topicsOfCategory = widget.vm.topicsOfCategory;</span><br><span class="line">      FetchTopics fetchTopics = widget.vm.fetchTopics;</span><br><span class="line">      ResetTopics resetTopics = widget.vm.resetTopics;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 循环显示分类下的主题列表</span></span><br><span class="line">      <span class="built_in">List</span>&lt;Widget&gt; _renderTabView() &#123;</span><br><span class="line">        <span class="keyword">final</span> _tabViews = &lt;Widget&gt;[];</span><br><span class="line">        topicsOfCategory.forEach((k, category) &#123;</span><br><span class="line">          <span class="built_in">bool</span> isFetched = topicsOfCategory[k][<span class="string">&quot;isFetched&quot;</span>];</span><br><span class="line">          <span class="comment">// 如果该分类下的主题列表未初始化先渲染一个加载指示</span></span><br><span class="line">          _tabViews.add(!isFetched ? _renderLoading(context) :</span><br><span class="line">          <span class="comment">// 使用 pull_to_refresh 包提供的下拉刷新和上来加载功能</span></span><br><span class="line">          <span class="keyword">new</span> SmartRefresher(</span><br><span class="line">            enablePullDown: <span class="keyword">true</span>,</span><br><span class="line">            enablePullUp: <span class="keyword">true</span>,</span><br><span class="line">            onRefresh: _onRefresh(k),</span><br><span class="line">            controller: _controller,</span><br><span class="line">            child: <span class="keyword">new</span> ListView.builder(</span><br><span class="line">              physics: <span class="keyword">const</span> NeverScrollableScrollPhysics(),</span><br><span class="line">              shrinkWrap: <span class="keyword">true</span>,</span><br><span class="line">              itemCount: topicsOfCategory[k][<span class="string">&quot;list&quot;</span>].length,</span><br><span class="line">              itemBuilder: (BuildContext context, <span class="built_in">int</span> i) =&gt; _renderRow(context, topicsOfCategory[k][<span class="string">&quot;list&quot;</span>][i]),</span><br><span class="line">            ),</span><br><span class="line">          ));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> _tabViews;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 使用 ListTile 渲染列表中的每一行</span></span><br><span class="line">      Widget _renderRow(BuildContext context, Topic topic) &#123;</span><br><span class="line">      ListTile title = <span class="keyword">new</span> ListTile(</span><br><span class="line">        leading: <span class="keyword">new</span> SizedBox(</span><br><span class="line">          width: <span class="number">30.0</span>,</span><br><span class="line">          height: <span class="number">30.0</span>,</span><br><span class="line">          <span class="comment">// 使用 cached_network_image 提供支持缓存和占位图的功能显示头像</span></span><br><span class="line">          child: <span class="keyword">new</span> CachedNetworkImage(</span><br><span class="line">            imageUrl: topic.authorAvatar.startsWith(<span class="string">&#x27;//&#x27;</span>) ? <span class="string">&#x27;http:<span class="subst">$&#123;topic.authorAvatar&#125;</span>&#x27;</span> : topic.authorAvatar,</span><br><span class="line">            placeholder: <span class="keyword">new</span> Image.asset(<span class="string">&#x27;asset/image/cnoder_avatar.png&#x27;</span>),</span><br><span class="line">            errorWidget: <span class="keyword">new</span> Icon(Icons.error),</span><br><span class="line">          )</span><br><span class="line">        ),</span><br><span class="line">        title: <span class="keyword">new</span> Text(topic.authorName),</span><br><span class="line">        subtitle: <span class="keyword">new</span> Row(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="keyword">new</span> Text(topic.lastReplyAt)</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        trailing: <span class="keyword">new</span> Text(<span class="string">&#x27;<span class="subst">$&#123;topic.replyCount&#125;</span>/<span class="subst">$&#123;topic.visitCount&#125;</span>&#x27;</span>),</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> InkWell(</span><br><span class="line">        <span class="comment">// 点击后跳转至主题详情</span></span><br><span class="line">        onTap: () =&gt; Navigator.of(context).pushNamed(<span class="string">&#x27;/topic/<span class="subst">$&#123;topic.id&#125;</span>&#x27;</span>),</span><br><span class="line">        child: <span class="keyword">new</span> Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            title,</span><br><span class="line">            <span class="keyword">new</span> Container(</span><br><span class="line">              padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">10.0</span>),</span><br><span class="line">              alignment: Alignment.centerLeft,</span><br><span class="line">              child: <span class="keyword">new</span> Text(topic.title),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">        appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">          brightness: Brightness.dark,</span><br><span class="line">          elevation: <span class="number">0.0</span>,</span><br><span class="line">          titleSpacing: <span class="number">0.0</span>,</span><br><span class="line">          bottom: <span class="keyword">null</span>,</span><br><span class="line">          <span class="comment">// 顶部显示页签栏</span></span><br><span class="line">          title: <span class="keyword">new</span> Align(</span><br><span class="line">            alignment: Alignment.bottomCenter,</span><br><span class="line">            child: <span class="keyword">new</span> TabBar(</span><br><span class="line">              labelColor: Colors.white,</span><br><span class="line">              tabs: _tabs,</span><br><span class="line">              controller: _tabController,</span><br><span class="line">            )</span><br><span class="line">          )</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 主体区域显示页签内容</span></span><br><span class="line">        body: <span class="keyword">new</span> TabBarView(</span><br><span class="line">          controller: _tabController,</span><br><span class="line">          children: _renderTabView(),</span><br><span class="line">        )</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据状态-1"><a href="#数据状态-1" class="headerlink" title="数据状态"></a>数据状态</h2><ul>
<li><code>store/view_model/topics.dart</code> 视图映射模型定义</li>
</ul>
<p>通过视图映射模型将 store 里面的 state 和 action 传递给视图widget,<br>在上面的主题容器widget里面我们通过 <code>vm.fetchTopics</code> 方法获取主题数据, 这个方法是在 TopicsViewModel 这个<br>store 映射模型里定义的</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopicsViewModel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">Map</span> topicsOfCategory;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">bool</span> isLoading;</span><br><span class="line">  <span class="keyword">final</span> FetchTopics fetchTopics;</span><br><span class="line">  <span class="keyword">final</span> ResetTopics resetTopics;</span><br><span class="line"></span><br><span class="line">  TopicsViewModel(&#123;</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.topicsOfCategory, </span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.isLoading, </span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.fetchTopics, </span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.resetTopics</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> TopicsViewModel fromStore(Store&lt;RootState&gt; store) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TopicsViewModel(</span><br><span class="line">      <span class="comment">// 映射分类主题列表</span></span><br><span class="line">      topicsOfCategory: store.state.topicsOfCategory,</span><br><span class="line">      <span class="comment">// 映射加载状态</span></span><br><span class="line">      isLoading: store.state.isLoading,</span><br><span class="line">      <span class="comment">// 获取主题数据 action 的包装方法</span></span><br><span class="line">      fetchTopics: (&#123;<span class="built_in">int</span> currentPage = <span class="number">1</span>, <span class="built_in">String</span> category = <span class="string">&#x27;&#x27;</span>, <span class="built_in">Function</span> afterFetched = _noop&#125;) &#123;</span><br><span class="line">        <span class="comment">// 通过 isLoading 数据状态的变更来切换widget的加载指示器的显示</span></span><br><span class="line">        store.dispatch(<span class="keyword">new</span> ToggleLoading(<span class="keyword">true</span>));</span><br><span class="line">        <span class="comment">// 触发获取主题数据的action,将当前页,分类名,以及调用成功的回调函数传递给action</span></span><br><span class="line">        store.dispatch(<span class="keyword">new</span> RequestTopics(currentPage: currentPage, category: category, afterFetched: afterFetched));</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 刷新主题数据的包装方法</span></span><br><span class="line">      resetTopics: (&#123;<span class="meta">@required</span> <span class="built_in">String</span> category, <span class="meta">@required</span> <span class="built_in">Function</span> afterFetched&#125;) &#123;</span><br><span class="line">        store.dispatch(<span class="keyword">new</span> RequestTopics(currentPage: <span class="number">1</span>, category: category, afterFetched: afterFetched));</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里增加了一个调用成功的回调函数给 action,是因为需要在 http 服务调用完成以后控制主题视图widget里面 SmartRefresher 这个widget 状态的切换(重置加载指示等等)</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> _onRefresh = (<span class="built_in">String</span> category) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">bool</span> up) &#123;</span><br><span class="line">      <span class="comment">// 如果是上拉加载更多</span></span><br><span class="line">      <span class="keyword">if</span> (!up) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isLoading) &#123;</span><br><span class="line">          _controller.sendBack(<span class="keyword">false</span>, RefreshStatus.idle);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fetchTopics(</span><br><span class="line">          currentPage: topicsOfCategory[category][<span class="string">&quot;currentPage&quot;</span>] + <span class="number">1</span>,</span><br><span class="line">          category: category,</span><br><span class="line">          afterFetched: () &#123;</span><br><span class="line">            <span class="comment">// 上拉加载更多指示器复位</span></span><br><span class="line">            _controller.sendBack(<span class="keyword">false</span>, RefreshStatus.idle);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      <span class="comment">// 如果是下拉刷新</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resetTopics(</span><br><span class="line">          category: category,</span><br><span class="line">          afterFetched: () &#123;</span><br><span class="line">            <span class="comment">// 下拉刷新指示器复位</span></span><br><span class="line">            _controller.sendBack(<span class="keyword">true</span>, RefreshStatus.completed);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>store/action/topic.dart</code> action 定义</li>
</ul>
<p>在 flutter 中以类的方式来定义 action 的,这一点与我们在 react 中使用 redux 有点不同</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送主题列表请求的 action</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestTopics</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当前页</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> currentPage;</span><br><span class="line">  <span class="comment">// 分类</span></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> category;</span><br><span class="line">  <span class="comment">// 请求完成的回调</span></span><br><span class="line">  <span class="keyword">final</span> VoidCallback afterFetched;</span><br><span class="line"></span><br><span class="line">  RequestTopics(&#123;<span class="keyword">this</span>.currentPage = <span class="number">1</span>, <span class="keyword">this</span>.category = <span class="string">&quot;&quot;</span>, <span class="meta">@required</span> <span class="keyword">this</span>.afterFetched&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应主题列表请求的 action</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResponseTopics</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">List</span>&lt;Topic&gt; topics;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> currentPage;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> category;</span><br><span class="line"></span><br><span class="line">  ResponseTopics(<span class="keyword">this</span>.currentPage, <span class="keyword">this</span>.category, <span class="keyword">this</span>.topics);</span><br><span class="line"></span><br><span class="line">  ResponseTopics.failed() : <span class="keyword">this</span>(<span class="number">1</span>, <span class="string">&quot;&quot;</span>, []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>epic 定义,redux epic 可以看成是 action 的一个调度器,虽然 flutter 里的redux 也有 redux_thunk 中间件,但是 epic 这种基于流的调度中间件使得业务逻辑更加优雅</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Stream&lt;<span class="built_in">dynamic</span>&gt; fetchTopicsEpic(</span><br><span class="line">    Stream&lt;<span class="built_in">dynamic</span>&gt; actions, EpicStore&lt;RootState&gt; store) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observable(actions)</span><br><span class="line">      <span class="comment">// 过滤特定请求</span></span><br><span class="line">      .ofType(<span class="keyword">new</span> TypeToken&lt;RequestTopics&gt;())</span><br><span class="line">      .flatMap((action) &#123;</span><br><span class="line">        <span class="comment">// 通过异步生成器来构建一个流</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Observable(() <span class="keyword">async</span>* &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 发送获取主题列表的 http 请求</span></span><br><span class="line">            <span class="keyword">final</span> ret = <span class="keyword">await</span> http.<span class="keyword">get</span>(<span class="string">&quot;<span class="subst">$&#123;apis[<span class="string">&#x27;topics&#x27;</span>]&#125;</span>?page=<span class="subst">$&#123;action.currentPage&#125;</span>&amp;limit=6&amp;tab=<span class="subst">$&#123;action.category&#125;</span>&amp;mdrender=false&quot;</span>);</span><br><span class="line">            <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">dynamic</span>&gt; result = json.decode(ret.body);</span><br><span class="line">            <span class="built_in">List</span>&lt;Topic&gt; topics = [];</span><br><span class="line">            result[<span class="string">&#x27;data&#x27;</span>].forEach((v) &#123;</span><br><span class="line">              topics.add(<span class="keyword">new</span> Topic.fromJson(v));</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">// 触发请求完成的回调,就是我们上面提到的 SmartRefresher widget 的复位</span></span><br><span class="line">            action.afterFetched();</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">new</span> ResponseTopics(action.currentPage, action.category, topics);</span><br><span class="line">          &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">            <span class="built_in">print</span>(err);</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">new</span> ResponseTopicsFailed(err);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 刷新数据状态复位</span></span><br><span class="line">          <span class="keyword">yield</span> <span class="keyword">new</span> ToggleLoading(<span class="keyword">false</span>);</span><br><span class="line">        &#125; ());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在接收到请求响应后,通过 <code>Topic.fromJson</code> 这个指定类构造器来创建主题列表,这个方法定义在 <code>store/model/topic.dart</code>里面</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Topic.fromJson(<span class="keyword">final</span> <span class="built_in">Map</span> map):</span><br><span class="line">    <span class="keyword">this</span>.id = map[<span class="string">&quot;id&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.authorName = map[<span class="string">&quot;author&quot;</span>][<span class="string">&quot;loginname&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.authorAvatar = map[<span class="string">&quot;author&quot;</span>][<span class="string">&quot;avatar_url&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.title = map[<span class="string">&quot;title&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.tag = map[<span class="string">&quot;tab&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.content = map[<span class="string">&quot;content&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.createdAt = fromNow(map[<span class="string">&quot;create_at&quot;</span>]),</span><br><span class="line">    <span class="keyword">this</span>.lastReplyAt = fromNow(map[<span class="string">&quot;last_reply_at&quot;</span>]),</span><br><span class="line">    <span class="keyword">this</span>.replyCount = map[<span class="string">&quot;reply_count&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.visitCount = map[<span class="string">&quot;visit_count&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.top = map[<span class="string">&quot;top&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.isCollect = map[<span class="string">&quot;is_collect&quot;</span>],</span><br><span class="line">    <span class="keyword">this</span>.replies = formatedReplies(map[<span class="string">&#x27;replies&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>store/reducer/topic.dart</code>, 通过主题列表的 reducer 来变更 store 里面的数据状态</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Reducer&lt;<span class="built_in">Map</span>&gt; topicsReducer = combineReducers([</span><br><span class="line">  <span class="comment">// 通过指定 action 类型来拆分</span></span><br><span class="line">  <span class="keyword">new</span> TypedReducer&lt;<span class="built_in">Map</span>, ClearTopic&gt;(_clearTopic),</span><br><span class="line">  <span class="keyword">new</span> TypedReducer&lt;<span class="built_in">Map</span>, RequestTopics&gt;(_requestTopics),</span><br><span class="line">  <span class="keyword">new</span> TypedReducer&lt;<span class="built_in">Map</span>, ResponseTopics&gt;(_responseTopics)</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空主题列表</span></span><br><span class="line"><span class="built_in">Map</span> _clearTopic(<span class="built_in">Map</span> state, ClearTopic action) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span> _requestTopics(<span class="built_in">Map</span> state, RequestTopics action) &#123;</span><br><span class="line">  <span class="built_in">Map</span> topicsOfTopics = &#123;&#125;;</span><br><span class="line">  state.forEach((k, v) &#123;</span><br><span class="line">    <span class="keyword">final</span> _v = <span class="keyword">new</span> <span class="built_in">Map</span>.from(v);</span><br><span class="line">    <span class="keyword">if</span> (action.category == k) &#123;</span><br><span class="line">      <span class="comment">// 通过 isFetched 标志位来防止分类页面切换时重复请求</span></span><br><span class="line">      _v[<span class="string">&quot;isFetched&quot;</span>] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    topicsOfTopics[k] = _v;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> topicsOfTopics;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Map</span> _responseTopics(<span class="built_in">Map</span> state, ResponseTopics action) &#123;</span><br><span class="line">  <span class="built_in">Map</span> topicsOfCategory = &#123;&#125;;</span><br><span class="line">  state.forEach((k, v) &#123;</span><br><span class="line">    <span class="built_in">Map</span> _v = &#123;&#125;;</span><br><span class="line">    _v.addAll(v);</span><br><span class="line">    <span class="keyword">if</span> (k == action.category) &#123;</span><br><span class="line">      <span class="built_in">List</span> _list = [];</span><br><span class="line">      <span class="comment">// 上拉加载更多时</span></span><br><span class="line">      <span class="keyword">if</span> (_v[<span class="string">&#x27;currentPage&#x27;</span>] &lt; action.currentPage) &#123;</span><br><span class="line">        _list.addAll(_v[<span class="string">&quot;list&quot;</span>]);</span><br><span class="line">        _list.addAll(action.topics);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="comment">// 下拉刷新时</span></span><br><span class="line">      <span class="keyword">if</span> (action.currentPage == <span class="number">1</span>) &#123;</span><br><span class="line">        _list.addAll(action.topics);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 通过 isFetched 标志位来防止分类页面切换时重复请求</span></span><br><span class="line">      _v[<span class="string">&quot;isFetched&quot;</span>] = <span class="keyword">true</span>;</span><br><span class="line">      _v[<span class="string">&quot;list&quot;</span>] = _list;</span><br><span class="line">      _v[<span class="string">&quot;currentPage&quot;</span>] = action.currentPage;</span><br><span class="line">    &#125;</span><br><span class="line">    topicsOfCategory[k] = _v;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> topicsOfCategory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>store/reducer/root.dart</code> 的 rootReducer 里进行合并</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">RootState rootReducer(RootState state, action) &#123;</span><br><span class="line">  <span class="comment">// 处理从持久化存储里加载数据状态</span></span><br><span class="line">  <span class="keyword">if</span> (action <span class="keyword">is</span> PersistLoadedAction&lt;RootState&gt;) &#123;</span><br><span class="line">    <span class="keyword">return</span> action.state ?? state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将 state 里的数据状态对应到子 reducer</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RootState(</span><br><span class="line">    tabIndex: tabReducer(state.tabIndex, action),</span><br><span class="line">    auth:  loginReducer(state.auth, action),</span><br><span class="line">    isLoading: loadingReducer(state.isLoading, action),</span><br><span class="line">    topicsOfCategory: topicsReducer(state.topicsOfCategory, action),</span><br><span class="line">    topic: topicReducer(state.topic, action),</span><br><span class="line">    me: meReducer(state.me, action),</span><br><span class="line">    collects: collectsReducer(state.collects, action),</span><br><span class="line">    messages: messagesReducer(state.messages, action)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>store/index.dart</code> store 的初始化入口,在我们上面的入口widget里面使用 <code>StoreProvider</code> 容器包裹的时候传递</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并 epic 获得根 epic 提供给 epic 中间件调用</span></span><br><span class="line"><span class="keyword">final</span> epic = combineEpics([</span><br><span class="line">  doLoginEpic, </span><br><span class="line">  fetchTopicsEpic, fetchTopicEpic, </span><br><span class="line">  fetchMeEpic,</span><br><span class="line">  fetchCollectsEpic,</span><br><span class="line">  fetchMessagesEpic,</span><br><span class="line">  fetchMessageCountEpic,</span><br><span class="line">  markAllAsReadEpic,</span><br><span class="line">  markAsReadEpic,</span><br><span class="line">  createReplyEpic,</span><br><span class="line">  saveTopicEpic,</span><br><span class="line">  createTopicEpic,</span><br><span class="line">  toggleCollectEpic,</span><br><span class="line">  likeReplyEpic,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化持久化中间件存储容器</span></span><br><span class="line"><span class="keyword">final</span> persistor = Persistor&lt;RootState&gt;(</span><br><span class="line">  storage: FlutterStorage(<span class="string">&#x27;cnoder&#x27;</span>),</span><br><span class="line">  decoder: RootState.fromJson,</span><br><span class="line">  debug: <span class="keyword">true</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 store</span></span><br><span class="line"><span class="keyword">final</span> store = <span class="keyword">new</span> Store&lt;RootState&gt;(rootReducer,</span><br><span class="line">  initialState: <span class="keyword">new</span> RootState(), middleware: [</span><br><span class="line">    <span class="keyword">new</span> LoggingMiddleware.printer(), </span><br><span class="line">    <span class="keyword">new</span> EpicMiddleware(epic),</span><br><span class="line">    persistor.createMiddleware()</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>这里有个小坑,持久化存储中间件 redux_persist 的文档上加载中间件的方式为</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> store = <span class="keyword">new</span> Store&lt;AppState&gt;(</span><br><span class="line">  reducer,</span><br><span class="line">  initialState: <span class="keyword">new</span> AppState(),</span><br><span class="line">  middleware: [persistor.createMiddleware()],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>但是这样处理的话,在每个业务 action 触发的时候,都会触发持久化的操作,而这在很多场景下是不必要的,比如在我们的应用中只需要保存的用户身份令牌,所以只需要在触发登陆和登出 action 的时候执行持久化的操作,因此加载中间件的方式需要做如下改动</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> persistMiddleware(Store store, <span class="built_in">dynamic</span> action, NextDispatcher next) &#123;</span><br><span class="line">  next(action);</span><br><span class="line">  <span class="comment">// 仅处理登陆和登出操作</span></span><br><span class="line">  <span class="keyword">if</span> (action <span class="keyword">is</span> FinishLogin || action <span class="keyword">is</span> Logout) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      persistor.save(store);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (_) &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 store</span></span><br><span class="line"><span class="keyword">final</span> store = <span class="keyword">new</span> Store&lt;RootState&gt;(rootReducer,</span><br><span class="line">  initialState: <span class="keyword">new</span> RootState(), middleware: [</span><br><span class="line">    <span class="keyword">new</span> LoggingMiddleware.printer(), </span><br><span class="line">    <span class="keyword">new</span> EpicMiddleware(epic),</span><br><span class="line">    persistMiddleware</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h2 id="更多-1"><a href="#更多-1" class="headerlink" title="更多"></a>更多</h2><p>应用的视图层和数据状态处理还是跟使用 React-Native 开发中使用 redux 技术栈的方式差不多,虽然整体目录结构有点繁琐,但是业务逻辑清晰明了,在后续功能扩展和维护的时候还是带来不少的方便,唯一遗憾的是因为 flutter 系统架构的问题,还没有一个针对 flutter 的 redux devtools,这一点还是蛮影响开发效率的</p>
<p>完整的项目源码请关注github仓库: <a href="https://github.com/ali322/cnoder">cnoder</a>,欢迎 star 和 PR,对 flutter 理解的不深,还望各位对本文中的不足之处批评指正</p>
]]></content>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
</search>
